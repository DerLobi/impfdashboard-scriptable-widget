{"version":3,"file":"vega-crossfilter.min.js","sources":["../src/arrays.js","../src/Bitmaps.js","../src/Dimension.js","../../../node_modules/d3-array/src/ascending.js","../../../node_modules/d3-array/src/bisector.js","../../../node_modules/d3-array/src/bisect.js","../../../node_modules/d3-array/src/number.js","../src/SortedIndex.js","../../../node_modules/d3-array/src/permute.js","../src/CrossFilter.js","../src/ResolveFilter.js"],"sourcesContent":["export const array8 = n => new Uint8Array(n);\n\nexport const array16 = n => new Uint16Array(n);\n\nexport const array32 = n => new Uint32Array(n);\n","import {array16, array32, array8} from './arrays';\n\n/**\n * Maintains CrossFilter state.\n */\nexport default function Bitmaps() {\n\n  let width = 8,\n      data = [],\n      seen = array32(0),\n      curr = array(0, width),\n      prev = array(0, width);\n\n  return {\n    data: () => data,\n\n    seen: () => (seen = lengthen(seen, data.length)),\n\n    add(array) {\n      for (let i=0, j=data.length, n=array.length, t; i<n; ++i) {\n        t = array[i];\n        t._index = j++;\n        data.push(t);\n      }\n    },\n\n    remove(num, map) { // map: index -> boolean (true => remove)\n      const n = data.length,\n            copy = Array(n - num),\n            reindex = data; // reuse old data array for index map\n      let t, i, j;\n\n      // seek forward to first removal\n      for (i=0; !map[i] && i<n; ++i) {\n        copy[i] = data[i];\n        reindex[i] = i;\n      }\n\n      // condense arrays\n      for (j=i; i<n; ++i) {\n        t = data[i];\n        if (!map[i]) {\n          reindex[i] = j;\n          curr[j] = curr[i];\n          prev[j] = prev[i];\n          copy[j] = t;\n          t._index = j++;\n        } else {\n          reindex[i] = -1;\n        }\n        curr[i] = 0; // clear unused bits\n      }\n\n      data = copy;\n      return reindex;\n    },\n\n    size: () => data.length,\n\n    curr: () => curr,\n\n    prev: () => prev,\n\n    reset: k => prev[k] = curr[k],\n\n    all: () =>\n      width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,\n\n    set(k, one) { curr[k] |= one; },\n\n    clear(k, one) { curr[k] &= ~one; },\n\n    resize(n, m) {\n      const k = curr.length;\n      if (n > k || m > width) {\n        width = Math.max(m, width);\n        curr = array(n, width, curr);\n        prev = array(n, width);\n      }\n    }\n  };\n}\n\nfunction lengthen(array, length, copy) {\n  if (array.length >= length) return array;\n  copy = copy || new array.constructor(length);\n  copy.set(array);\n  return copy;\n}\n\nfunction array(n, m, array) {\n  const copy = (m < 0x101 ? array8\n      : m < 0x10001 ? array16\n      : array32)(n);\n  if (array) copy.set(array);\n  return copy;\n}\n","export default function(index, i, query) {\n  const bit = (1 << i);\n\n  return {\n    one:     bit,\n    zero:    ~bit,\n    range:   query.slice(),\n    bisect:  index.bisect,\n    index:   index.index,\n    size:    index.size,\n\n    onAdd(added, curr) {\n      const dim = this,\n            range = dim.bisect(dim.range, added.value),\n            idx = added.index,\n            lo = range[0],\n            hi = range[1],\n            n1 = idx.length;\n      let i;\n\n      for (i=0;  i<lo; ++i) curr[idx[i]] |= bit;\n      for (i=hi; i<n1; ++i) curr[idx[i]] |= bit;\n      return dim;\n    }\n  };\n}\n","export default function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","import ascending from \"./ascending.js\";\n\nexport default function(f) {\n  let delta = f;\n  let compare = f;\n\n  if (f.length === 1) {\n    delta = (d, x) => f(d) - x;\n    compare = ascendingComparator(f);\n  }\n\n  function left(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (compare(a[mid], x) < 0) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  function right(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (compare(a[mid], x) > 0) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  function center(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction ascendingComparator(f) {\n  return (d, x) => ascending(f(d), x);\n}\n","import ascending from \"./ascending.js\";\nimport bisector from \"./bisector.js\";\nimport number from \"./number.js\";\n\nconst ascendingBisect = bisector(ascending);\nexport const bisectRight = ascendingBisect.right;\nexport const bisectLeft = ascendingBisect.left;\nexport const bisectCenter = bisector(number).center;\nexport default bisectRight;\n","export default function(x) {\n  return x === null ? NaN : +x;\n}\n\nexport function* numbers(values, valueof) {\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  }\n}\n","import {array32} from './arrays';\nimport {bisectLeft, bisectRight, permute} from 'd3-array';\n\n/**\n * Maintains a list of values, sorted by key.\n */\nexport default function SortedIndex() {\n  let index = array32(0),\n      value = [],\n      size = 0;\n\n  function insert(key, data, base) {\n    if (!data.length) return [];\n\n    const n0 = size,\n        n1 = data.length,\n        addi = array32(n1);\n    let addv = Array(n1),\n        oldv, oldi, i;\n\n    for (i=0; i<n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n    addv = sort(addv, addi);\n\n    if (n0) {\n      oldv = value;\n      oldi = index;\n      value = Array(n0 + n1);\n      index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n    } else {\n      if (base > 0) for (i=0; i<n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      index = addi;\n    }\n    size = n0 + n1;\n\n    return {index: addi, value: addv};\n  }\n\n  function remove(num, map) {\n    // map: index -> remove\n    const n = size;\n    let idx, i, j;\n\n    // seek forward to first removal\n    for (i=0; !map[index[i]] && i<n; ++i);\n\n    // condense index and value arrays\n    for (j=i; i<n; ++i) {\n      if (!map[idx=index[i]]) {\n        index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n\n    size = n - num;\n  }\n\n  function reindex(map) {\n    for (let i=0, n=size; i<n; ++i) {\n      index[i] = map[index[i]];\n    }\n  }\n\n  function bisect(range, array) {\n    let n;\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = size;\n    }\n    return [\n      bisectLeft(array, range[0], 0, n),\n      bisectRight(array, range[1], 0, n)\n    ];\n  }\n\n  return {\n    insert:  insert,\n    remove:  remove,\n    bisect:  bisect,\n    reindex: reindex,\n    index:   () => index,\n    size:    () => size\n  };\n}\n\nfunction sort(values, index) {\n  values.sort.call(index, (a, b) => {\n    const x = values[a],\n          y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\n\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  let i0 = 0, i1 = 0, i;\n\n  for (i=0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n","export default function(source, keys) {\n  return Array.from(keys, key => source[key]);\n}\n","import Bitmaps from './Bitmaps';\nimport Dimension from './Dimension';\nimport SortedIndex from './SortedIndex';\nimport {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\nexport default function CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\n\nCrossFilter.Definition = {\n  'type': 'CrossFilter',\n  'metadata': {},\n  'params': [\n    { 'name': 'fields', 'type': 'field', 'array': true, 'required': true },\n    { 'name': 'query', 'type': 'array', 'array': true, 'required': true,\n      'content': {'type': 'number', 'array': true, 'length': 2} }\n  ]\n};\n\ninherits(CrossFilter, Transform, {\n  transform(_, pulse) {\n    if (!this._dims) {\n      return this.init(_, pulse);\n    } else {\n      var init = _.modified('fields')\n            || _.fields.some(f => pulse.modified(f.fields));\n\n      return init\n        ? this.reinit(_, pulse)\n        : this.eval(_, pulse);\n    }\n  },\n\n  init(_, pulse) {\n    const fields = _.fields,\n          query = _.query,\n          indices = this._indices = {},\n          dims = this._dims = [],\n          m = query.length;\n    let i = 0, key, index;\n\n    // instantiate indices and dimensions\n    for (; i<m; ++i) {\n      key = fields[i].fname;\n      index = indices[key] || (indices[key] = SortedIndex());\n      dims.push(Dimension(index, i, query[i]));\n    }\n\n    return this.eval(_, pulse);\n  },\n\n  reinit(_, pulse) {\n    const output = pulse.materialize().fork(),\n          fields = _.fields,\n          query = _.query,\n          indices = this._indices,\n          dims = this._dims,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          out = (output.rem = output.add),\n          mod = output.mod,\n          m = query.length,\n          adds = {};\n    let add, index, key, mods, remMap, modMap, i, n, f;\n\n    // set prev to current state\n    prev.set(curr);\n\n    // if pulse has remove tuples, process them first\n    if (pulse.rem.length) {\n      remMap = this.remove(_, pulse, output);\n    }\n\n    // if pulse has added tuples, add them to state\n    if (pulse.add.length) {\n      bits.add(pulse.add);\n    }\n\n    // if pulse has modified tuples, create an index map\n    if (pulse.mod.length) {\n      modMap = {};\n      for (mods=pulse.mod, i=0, n=mods.length; i<n; ++i) {\n        modMap[mods[i]._index] = 1;\n      }\n    }\n\n    // re-initialize indices as needed, update curr bitmap\n    for (i=0; i<m; ++i) {\n      f = fields[i];\n      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n        key = f.fname;\n        if (!(add = adds[key])) {\n          indices[key] = index = SortedIndex();\n          adds[key] = add = index.insert(f, pulse.source, 0);\n        }\n        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n      }\n    }\n\n    // visit each tuple\n    // if filter state changed, push index to add/rem\n    // else if in mod and passes a filter, push index to mod\n    for (i=0, n=bits.data().length; i<n; ++i) {\n      if (remMap[i]) { // skip if removed tuple\n        continue;\n      } else if (prev[i] !== curr[i]) { // add if state changed\n        out.push(i);\n      } else if (modMap[i] && curr[i] !== all) { // otherwise, pass mods through\n        mod.push(i);\n      }\n    }\n\n    bits.mask = (1 << m) - 1;\n    return output;\n  },\n\n  eval(_, pulse) {\n    const output = pulse.materialize().fork(),\n          m = this._dims.length;\n    let mask = 0;\n\n    if (pulse.rem.length) {\n      this.remove(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (_.modified('query') && !_.modified('fields')) {\n      mask |= this.update(_, pulse, output);\n    }\n\n    if (pulse.add.length) {\n      this.insert(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (pulse.mod.length) {\n      this.modify(pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    this.value.mask = mask;\n    return output;\n  },\n\n  insert(_, pulse, output) {\n    const tuples = pulse.add,\n          bits = this.value,\n          dims = this._dims,\n          indices = this._indices,\n          fields = _.fields,\n          adds = {},\n          out = output.add,\n          n = bits.size() + tuples.length,\n          m = dims.length;\n    let k = bits.size(), j, key, add;\n\n    // resize bitmaps and add tuples as needed\n    bits.resize(n, m);\n    bits.add(tuples);\n\n    const curr = bits.curr(),\n          prev = bits.prev(),\n          all  = bits.all();\n\n    // add to dimensional indices\n    for (j=0; j<m; ++j) {\n      key = fields[j].fname;\n      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n      dims[j].onAdd(add, curr);\n    }\n\n    // set previous filters, output if passes at least one filter\n    for (; k < n; ++k) {\n      prev[k] = all;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  modify(pulse, output) {\n    const out = output.mod,\n          bits = this.value,\n          curr = bits.curr(),\n          all  = bits.all(),\n          tuples = pulse.mod;\n    let i, n, k;\n\n    for (i=0, n=tuples.length; i<n; ++i) {\n      k = tuples[i]._index;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  remove(_, pulse, output) {\n    const indices = this._indices,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all  = bits.all(),\n          map = {},\n          out = output.rem,\n          tuples = pulse.rem;\n    let i, n, k, f;\n\n    // process tuples, output if passes at least one filter\n    for (i=0, n=tuples.length; i<n; ++i) {\n      k = tuples[i]._index;\n      map[k] = 1; // build index map\n      prev[k] = (f = curr[k]);\n      curr[k] = all;\n      if (f !== all) out.push(k);\n    }\n\n    // remove from dimensional indices\n    for (k in indices) {\n      indices[k].remove(n, map);\n    }\n\n    this.reindex(pulse, n, map);\n    return map;\n  },\n\n  // reindex filters and indices after propagation completes\n  reindex(pulse, num, map) {\n    const indices = this._indices,\n          bits = this.value;\n\n    pulse.runAfter(() => {\n      const indexMap = bits.remove(num, map);\n      for (const key in indices) indices[key].reindex(indexMap);\n    });\n  },\n\n  update(_, pulse, output) {\n    const dims = this._dims,\n          query = _.query,\n          stamp = pulse.stamp,\n          m = dims.length;\n    let mask = 0, i, q;\n\n    // survey how many queries have changed\n    output.filters = 0;\n    for (q=0; q<m; ++q) {\n      if (_.modified('query', q)) { i = q; ++mask; }\n    }\n\n    if (mask === 1) {\n      // only one query changed, use more efficient update\n      mask = dims[i].one;\n      this.incrementOne(dims[i], query[i], output.add, output.rem);\n    } else {\n      // multiple queries changed, perform full record keeping\n      for (q=0, mask=0; q<m; ++q) {\n        if (!_.modified('query', q)) continue;\n        mask |= dims[q].one;\n        this.incrementAll(dims[q], query[q], stamp, output.add);\n        output.rem = output.add; // duplicate add/rem for downstream resolve\n      }\n    }\n\n    return mask;\n  },\n\n  incrementAll(dim, query, stamp, out) {\n    const bits = this.value,\n          seen = bits.seen(),\n          curr = bits.curr(),\n          prev = bits.prev(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k;\n\n    // Fast incremental update based on previous lo index.\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    }\n\n    // Fast incremental update based on previous hi index.\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    }\n\n    dim.range = query.slice();\n  },\n\n  incrementOne(dim, query, add, rem) {\n    const bits = this.value,\n          curr = bits.curr(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k;\n\n    // Fast incremental update based on previous lo index.\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    // Fast incremental update based on previous hi index.\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    dim.range = query.slice();\n  }\n});\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\nexport default function ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\n\nResolveFilter.Definition = {\n  'type': 'ResolveFilter',\n  'metadata': {},\n  'params': [\n    { 'name': 'ignore', 'type': 'number', 'required': true,\n      'description': 'A bit mask indicating which filters to ignore.' },\n    { 'name': 'filter', 'type': 'object', 'required': true,\n      'description': 'Per-tuple filter bitmaps from a CrossFilter transform.' }\n  ]\n};\n\ninherits(ResolveFilter, Transform, {\n  transform(_, pulse) {\n    const ignore = ~(_.ignore || 0), // bit mask where zeros -> dims to ignore\n          bitmap = _.filter,\n          mask = bitmap.mask;\n\n    // exit early if no relevant filter changes\n    if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n    const output = pulse.fork(pulse.ALL),\n          data = bitmap.data(),\n          curr = bitmap.curr(),\n          prev = bitmap.prev(),\n          pass = k => !(curr[k] & ignore) ? data[k] : null;\n\n    // propagate all mod tuples that pass the filter\n    output.filter(output.MOD, pass);\n\n    // determine add & rem tuples via filter functions\n    // for efficiency, we do *not* populate new arrays,\n    // instead we add filter functions applied downstream\n\n    if (!(mask & (mask-1))) { // only one filter changed\n      output.filter(output.ADD, pass);\n      output.filter(output.REM, k =>\n        (curr[k] & ignore) === mask ? data[k] : null);\n\n    } else { // multiple filters changed\n      output.filter(output.ADD, k => {\n        const c = curr[k] & ignore,\n              f = !c && (c ^ (prev[k] & ignore));\n        return f ? data[k] : null;\n      });\n      output.filter(output.REM, k => {\n        const c = curr[k] & ignore,\n              f = c && !(c ^ (c ^ (prev[k] & ignore)));\n        return f ? data[k] : null;\n      });\n    }\n\n    // add filter to source data in case of reflow...\n    return output.filter(output.SOURCE, t => pass(t._index));\n  }\n});\n"],"names":["array8","n","Uint8Array","array16","Uint16Array","array32","Uint32Array","array","m","copy","set","index","i","query","bit","one","zero","range","slice","bisect","size","onAdd","added","curr","dim","this","value","idx","lo","hi","n1","length","a","b","NaN","f","delta","compare","left","x","mid","d","ascending","ascendingComparator","center","right","ascendingBisect","bisector","bisectRight","bisectLeft","SortedIndex","insert","key","data","base","n0","addi","oldv","oldi","addv","Array","values","sort","call","y","source","keys","from","permute","value0","index0","value1","index1","i0","i1","merge","remove","num","map","j","reindex","CrossFilter","params","Transform","width","seen","prev","constructor","lengthen","add","t","_index","push","reset","k","all","clear","resize","Math","max","Bitmaps","_indices","_dims","ResolveFilter","Definition","transform","_","pulse","modified","fields","some","reinit","eval","init","indices","dims","fname","Dimension","output","materialize","fork","bits","out","rem","mod","adds","mods","remMap","modMap","mask","update","modify","tuples","runAfter","indexMap","stamp","q","filters","incrementOne","incrementAll","old","lo1","hi1","lo0","hi0","min","ignore","bitmap","filter","StopPropagation","ALL","pass","MOD","ADD","c","REM","SOURCE"],"mappings":"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"}