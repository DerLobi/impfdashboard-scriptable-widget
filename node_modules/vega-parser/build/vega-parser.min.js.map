{"version":3,"file":"vega-parser.min.js","sources":["../src/parsers/autosize.js","../src/parsers/padding.js","../src/parsers/encode/util.js","../src/parsers/marks/roles.js","../src/parsers/encode/defaults.js","../src/parsers/encode/entry.js","../src/parsers/encode.js","../src/parsers/encode/rule.js","../src/parsers/signal.js","../src/util.js","../src/parsers/stream.js","../src/parsers/update.js","../src/parsers/signal-updates.js","../src/transforms.js","../src/parsers/scale.js","../src/parsers/projection.js","../src/parsers/guides/constants.js","../src/parsers/marks/marktypes.js","../src/parsers/guides/guide-group.js","../src/parsers/guides/guide-util.js","../src/parsers/guides/guide-mark.js","../src/parsers/guides/legend-gradient.js","../src/parsers/guides/legend-gradient-discrete.js","../src/parsers/guides/legend-gradient-labels.js","../src/parsers/guides/legend-symbol-groups.js","../src/parsers/guides/legend-title.js","../src/parsers/marks/clip.js","../src/parsers/marks/role.js","../src/parsers/marks/definition.js","../src/parsers/marks/interactive.js","../src/parsers/transform.js","../src/parsers/marks/data.js","../src/DataScope.js","../src/parsers/trigger.js","../src/parsers/mark.js","../src/parsers/marks/facet.js","../src/parsers/marks/subflow.js","../src/parsers/legend.js","../src/parsers/title.js","../src/parsers/data.js","../src/parsers/guides/axis-util.js","../src/parsers/guides/axis-config.js","../src/parsers/guides/axis-domain.js","../src/parsers/guides/axis-grid.js","../src/parsers/guides/axis-labels.js","../src/parsers/guides/axis-title.js","../src/parsers/axis.js","../src/parsers/guides/axis-ticks.js","../src/parsers/scope.js","../src/parsers/view.js","../src/Scope.js","../src/config.js","../src/parse.js"],"sourcesContent":["import {isObject} from 'vega-util';\n\nexport default function(spec) {\n  return isObject(spec) ? spec : {type: spec || 'pad'};\n}\n","import {isObject} from 'vega-util';\n\nconst number = _ => +_ || 0;\n\nconst paddingObject = _ => ({top: _, bottom: _, left: _, right: _});\n\nexport default function(spec) {\n  return !isObject(spec) ? paddingObject(number(spec))\n    : spec.signal ? spec\n    : {\n        top:    number(spec.top),\n        bottom: number(spec.bottom),\n        left:   number(spec.left),\n        right:  number(spec.right)\n      };\n}\n","import {extend, hasOwnProperty, isArray, isObject} from 'vega-util';\n\nexport const encoder = _ => isObject(_) && !isArray(_)\n  ? extend({}, _)\n  : {value: _};\n\nexport function addEncode(object, name, value, set) {\n  if (value != null) {\n    const isEncoder = (\n      (isObject(value) && !isArray(value)) ||\n      (isArray(value) && value.length && isObject(value[0]))\n    );\n\n    // Always assign signal to update, even if the signal is from the enter block\n    if (isEncoder) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {value: value};\n    }\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nexport function addEncoders(object, enter, update) {\n  for (const name in enter) {\n    addEncode(object, name, enter[name]);\n  }\n  for (const name in update) {\n    addEncode(object, name, update[name], 'update');\n  }\n}\n\nexport function extendEncode(encode, extra, skip) {\n  for (const name in extra) {\n    if (skip && hasOwnProperty(skip, name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n  return encode;\n}\n\nexport function has(key, encode) {\n  return encode && (\n    (encode.enter && encode.enter[key]) ||\n    (encode.update && encode.update[key])\n  );\n}\n","export const MarkRole = 'mark';\nexport const FrameRole = 'frame';\nexport const ScopeRole = 'scope';\n\nexport const AxisRole = 'axis';\nexport const AxisDomainRole = 'axis-domain';\nexport const AxisGridRole = 'axis-grid';\nexport const AxisLabelRole = 'axis-label';\nexport const AxisTickRole = 'axis-tick';\nexport const AxisTitleRole = 'axis-title';\n\nexport const LegendRole = 'legend';\nexport const LegendBandRole = 'legend-band';\nexport const LegendEntryRole = 'legend-entry';\nexport const LegendGradientRole = 'legend-gradient';\nexport const LegendLabelRole = 'legend-label';\nexport const LegendSymbolRole = 'legend-symbol';\nexport const LegendTitleRole = 'legend-title';\n\nexport const TitleRole = 'title';\nexport const TitleTextRole = 'title-text';\nexport const TitleSubtitleRole = 'title-subtitle';\n","import {has} from './util';\nimport {FrameRole, MarkRole} from '../marks/roles';\nimport {array, extend} from 'vega-util';\n\nexport default function(encode, type, role, style, config) {\n  const defaults = {}, enter = {};\n  let update, key, skip, props;\n\n  // if text mark, apply global lineBreak settings (#2370)\n  key = 'lineBreak';\n  if (type === 'text' && config[key] != null && !has(key, encode)) {\n    applyDefault(defaults, key, config[key]);\n  }\n\n  // ignore legend and axis roles\n  if (role == 'legend' || String(role).startsWith('axis')) {\n    role = null;\n  }\n\n  // resolve mark config\n  props = role === FrameRole ? config.group\n    : (role === MarkRole) ? extend({}, config.mark, config[type])\n    : null;\n\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode)\n      || (key === 'fill' || key === 'stroke')\n      && (has('fill', encode) || has('stroke', encode));\n\n    if (!skip) applyDefault(defaults, key, props[key]);\n  }\n\n  // resolve styles, apply with increasing precedence\n  array(style).forEach(name => {\n    const props = config.style && config.style[name];\n    for (const key in props) {\n      if (!has(key, encode)) {\n        applyDefault(defaults, key, props[key]);\n      }\n    }\n  });\n\n  encode = extend({}, encode); // defensive copy\n  for (key in defaults) {\n    props = defaults[key];\n    if (props.signal) {\n      (update = update || {})[key] = props;\n    } else {\n      enter[key] = props;\n    }\n  }\n\n  encode.enter = extend(enter, encode.enter);\n  if (update) encode.update = extend(update, encode.update);\n\n  return encode;\n}\n\nfunction applyDefault(defaults, key, value) {\n  defaults[key] = value && value.signal\n    ? {signal: value.signal}\n    : {value: value};\n}\n","import {error, isObject, isString, peek, splitAccessPath, stringValue} from 'vega-util';\n\nconst scaleRef = scale => isString(scale) ? stringValue(scale)\n  : scale.signal ? `(${scale.signal})`\n  : field(scale);\n\nexport default function entry(enc) {\n  if (enc.gradient != null) {\n    return gradient(enc);\n  }\n\n  let value = enc.signal ? `(${enc.signal})`\n    : enc.color ? color(enc.color)\n    : enc.field != null ? field(enc.field)\n    : enc.value !== undefined ? stringValue(enc.value)\n    : undefined;\n\n  if (enc.scale != null) {\n    value = scale(enc, value);\n  }\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  if (enc.exponent != null) {\n    value = `pow(${value},${property(enc.exponent)})`;\n  }\n\n  if (enc.mult != null) {\n    value += `*${property(enc.mult)}`;\n  }\n\n  if (enc.offset != null) {\n    value += `+${property(enc.offset)}`;\n  }\n\n  if (enc.round) {\n    value = `round(${value})`;\n  }\n\n  return value;\n}\n\nconst _color = (type, x, y, z) =>\n  `(${type}(${[x, y, z].map(entry).join(',')})+'')`;\n\nfunction color(enc) {\n  return (enc.c) ? _color('hcl', enc.h, enc.c, enc.l)\n    : (enc.h || enc.s) ? _color('hsl', enc.h, enc.s, enc.l)\n    : (enc.l || enc.a) ? _color('lab', enc.l, enc.a, enc.b)\n    : (enc.r || enc.g || enc.b) ? _color('rgb', enc.r, enc.g, enc.b)\n    : null;\n}\n\nfunction gradient(enc) {\n  // map undefined to null; expression lang does not allow undefined\n  const args = [enc.start, enc.stop, enc.count]\n    .map(_ => _ == null ? null : stringValue(_));\n\n  // trim null inputs from the end\n  while (args.length && peek(args) == null) args.pop();\n\n  args.unshift(scaleRef(enc.gradient));\n  return `gradient(${args.join(',')})`;\n}\n\nfunction property(property) {\n  return isObject(property) ? '(' + entry(property) + ')' : property;\n}\n\nfunction field(ref) {\n  return resolveField(isObject(ref) ? ref : {datum: ref});\n}\n\nfunction resolveField(ref) {\n  let object, level, field;\n\n  if (ref.signal) {\n    object = 'datum';\n    field = ref.signal;\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n\n  if (!ref.signal) {\n    field = isString(field)\n      ? splitAccessPath(field).map(stringValue).join('][')\n      : resolveField(field);\n  }\n\n  return object + '[' + field + ']';\n}\n\nfunction scale(enc, value) {\n  const scale = scaleRef(enc.scale);\n\n  if (enc.range != null) {\n    // pull value from scale range\n    value = `lerp(_range(${scale}), ${+enc.range})`;\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = `_scale(${scale}, ${value})`;\n\n    if (enc.band) {\n      value = (value ? value + '+' : '')\n        + `_bandwidth(${scale})`\n        + (+enc.band === 1 ? '' : '*' + property(enc.band));\n\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\n      }\n    }\n\n    if (value == null) value = '0';\n  }\n\n  return value;\n}\n","import applyDefaults from './encode/defaults';\nimport entry from './encode/entry';\nimport rule from './encode/rule';\n\nimport {parseExpression} from 'vega-functions';\nimport {extend, isArray} from 'vega-util';\n\nexport default function(encode, type, role, style, scope, params) {\n  const enc = {};\n  params = params || {};\n  params.encoders = {$encode: enc};\n\n  encode = applyDefaults(encode, type, role, style, scope.config);\n  for (const key in encode) {\n    enc[key] = parseBlock(encode[key], type, params, scope);\n  }\n\n  return params;\n}\n\nfunction parseBlock(block, marktype, params, scope) {\n  const channels = {},\n        fields = {};\n\n  for (const name in block) {\n    if (block[name] != null) { // skip any null entries\n      channels[name] = parse(expr(block[name]), scope, params, fields);\n    }\n  }\n\n  return {\n    $expr:   {marktype, channels},\n    $fields: Object.keys(fields),\n    $output: Object.keys(block)\n  };\n}\n\nfunction expr(enc) {\n  return isArray(enc) ? rule(enc) : entry(enc);\n}\n\nfunction parse(code, scope, params, fields) {\n  const expr = parseExpression(code, scope);\n  expr.$fields.forEach(name => fields[name] = 1);\n  extend(params, expr.$params);\n  return expr.$expr;\n}\n","import entry from './entry';\nimport {peek} from 'vega-util';\n\nexport default function(enc) {\n  let code = '';\n\n  enc.forEach(rule => {\n    const value = entry(rule);\n    code += rule.test ? `(${rule.test})?${value}:` : value;\n  });\n\n  // if no else clause, terminate with null (#1366)\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n\n  return code;\n}\n","import {error, stringValue} from 'vega-util';\n\nconst OUTER = 'outer',\n      OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\n\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\n\nexport default function(signal, scope) {\n  const name = signal.name;\n\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name);\n    // signal push must not use properties reserved for standard definition\n    OUTER_INVALID.forEach(prop => {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    const op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\n","import {isObject} from 'vega-util';\n\nexport function Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\n\nexport function entry(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\n\nexport function operator(value, params) {\n  return entry('operator', value, params);\n}\n\n// -----\n\nexport function ref(op) {\n  const ref = {$ref: op.id};\n  // if operator not yet registered, cache ref to resolve later\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\n\nexport const tupleidRef = {\n  $tupleid: 1,\n  toString: function() { return ':_tupleid_:'; }\n};\n\nexport function fieldRef(field, name) {\n  return name ? {$field: field, $name: name} : {$field: field};\n}\n\nexport const keyFieldRef = fieldRef('key');\n\nexport function compareRef(fields, orders) {\n  return {$compare: fields, $order: orders};\n}\n\nexport function keyRef(fields, flat) {\n  const ref = {$key: fields};\n  if (flat) ref.$flat = true;\n  return ref;\n}\n\n// -----\n\nexport const Ascending  = 'ascending';\n\nexport const Descending = 'descending';\n\nexport function sortKey(sort) {\n  return !isObject(sort) ? ''\n    : (sort.order === Descending ? '-' : '+')\n      + aggrField(sort.op, sort.field);\n}\n\nexport function aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '')\n    + (op && field ? '_' : '')\n    + (field && field.signal ? '$' + field.signal : field || '');\n}\n\n// -----\n\nexport const Scope = 'scope';\n\nexport const View = 'view';\n\nexport function isSignal(_) {\n  return _ && _.signal;\n}\n\nexport function isExpr(_) {\n  return _ && _.expr;\n}\n\nexport function hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (const key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\n\nexport function value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\n\nexport function deref(v) {\n  return v && v.signal || v;\n}\n","import {Scope, View} from '../util';\nimport {parseExpression} from 'vega-functions';\nimport {error, stringValue} from 'vega-util';\n\nconst Timer = 'timer';\n\nexport default function parseStream(stream, scope) {\n  const method = stream.merge ? mergeStream\n    : stream.stream ? nestedStream\n    : stream.type ? eventStream\n    : error('Invalid stream specification: ' + stringValue(stream));\n\n  return method(stream, scope);\n}\n\nfunction eventSource(source) {\n   return source === Scope ? View : (source || View);\n}\n\nfunction mergeStream(stream, scope) {\n  const list = stream.merge.map(s => parseStream(s, scope)),\n        entry = streamParameters({merge: list}, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction nestedStream(stream, scope) {\n  const id = parseStream(stream.stream, scope),\n        entry = streamParameters({stream: id}, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction eventStream(stream, scope) {\n  let id;\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {between: stream.between, filter: stream.filter};\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n\n  const entry = streamParameters({stream: id}, stream, scope);\n  return Object.keys(entry).length === 1\n    ? id\n    : scope.addStream(entry).id;\n}\n\nfunction streamParameters(entry, stream, scope) {\n  let param = stream.between;\n\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n    entry.between = [\n      parseStream(param[0], scope),\n      parseStream(param[1], scope)\n    ];\n  }\n\n  param = stream.filter ? [].concat(stream.filter) : [];\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n  if (stream.source === Scope) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n  }\n\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n\n  if (stream.consume) {\n    entry.consume = true;\n  }\n\n  return entry;\n}\n\nfunction filterMark(type, name, role) {\n  const item = 'event.item';\n  return item\n    + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '')\n    + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '')\n    + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\n","import parseStream from './stream';\nimport {Scope, View} from '../util';\nimport {selector} from 'vega-event-selector';\nimport {parseExpression} from 'vega-functions';\nimport {array, error, extend, isString, stringValue} from 'vega-util';\n\n// bypass expression parser for internal operator references\nconst OP_VALUE_EXPR = {\n  code: '_.$value',\n  ast: {type: 'Identifier', value: 'value'}\n};\n\nexport default function(spec, scope, target) {\n  const encode = spec.encode,\n        entry = {target: target};\n\n  let events = spec.events,\n      update = spec.update,\n      sources = [];\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  }\n\n  // interpret as an event selector string\n  if (isString(events)) {\n    events = selector(events, scope.isSubscope() ? Scope : View);\n  }\n\n  // separate event streams from signal updates\n  events = array(events)\n    .filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1);\n\n  // merge internal operator listeners\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  }\n\n  // merge event streams, include as source\n  if (events.length) {\n    sources.push(events.length > 1 ? {merge: events} : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  }\n\n  // resolve update value\n  entry.update = isString(update) ? parseExpression(update, scope)\n    : update.expr != null ? parseExpression(update.expr, scope)\n    : update.value != null ? update.value\n    : update.signal != null ? {\n        $expr:   OP_VALUE_EXPR,\n        $params: {$value: scope.signalRef(update.signal)}\n      }\n    : error('Invalid signal update specification.');\n\n  if (spec.force) {\n    entry.options = {force: true};\n  }\n\n  sources.forEach(source =>\n    scope.addUpdate(extend(streamSource(source, scope), entry))\n  );\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal)\n          : stream.scale ? scope.scaleRef(stream.scale)\n          : parseStream(stream, scope)\n  };\n}\n\nfunction mergeSources(sources) {\n  return {\n    signal: '['\n      + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal)\n      + ']'\n  };\n}\n","import parseUpdate from './update';\nimport {parseExpression} from 'vega-functions';\nimport {error} from 'vega-util';\n\nexport default function(signal, scope) {\n  const op = scope.getSignal(signal.name);\n  let expr = signal.update;\n\n  if (signal.init) {\n    if (expr) {\n      error('Signals can not include both init and update expressions.');\n    } else {\n      expr = signal.init;\n      op.initonly = true;\n    }\n  }\n\n  if (expr) {\n    expr = parseExpression(expr, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n\n  if (signal.on) {\n    signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n  }\n}\n","import {entry} from './util';\n\nconst transform = name => (params, value, parent) =>\n  entry(name, value, params || undefined, parent);\n\nexport const Aggregate = transform('aggregate');\nexport const AxisTicks = transform('axisticks');\nexport const Bound = transform('bound');\nexport const Collect = transform('collect');\nexport const Compare = transform('compare');\nexport const DataJoin = transform('datajoin');\nexport const Encode = transform('encode');\nexport const Expression = transform('expression');\nexport const Extent = transform('extent');\nexport const Facet = transform('facet');\nexport const Field = transform('field');\nexport const Key = transform('key');\nexport const LegendEntries = transform('legendentries');\nexport const Load = transform('load');\nexport const Mark = transform('mark');\nexport const MultiExtent = transform('multiextent');\nexport const MultiValues = transform('multivalues');\nexport const Overlap = transform('overlap');\nexport const Params = transform('params');\nexport const PreFacet = transform('prefacet');\nexport const Projection = transform('projection');\nexport const Proxy = transform('proxy');\nexport const Relay = transform('relay');\nexport const Render = transform('render');\nexport const Scale = transform('scale');\nexport const Sieve = transform('sieve');\nexport const SortItems = transform('sortitems');\nexport const ViewLayout = transform('viewlayout');\nexport const Values = transform('values');\n","import {\n  Aggregate, Collect, MultiExtent, MultiValues, Sieve, Values\n} from '../transforms';\nimport {aggrField, keyFieldRef, ref} from '../util';\n\nimport {isDiscrete, isQuantile, isValidScaleType} from 'vega-scale';\nimport {\n  error, extend, hasOwnProperty, isArray, isObject, isString, stringValue\n} from 'vega-util';\n\nlet FIELD_REF_ID = 0;\n\nconst MULTIDOMAIN_SORT_OPS  = {min: 'min', max: 'max', count: 'sum'};\n\nexport function initScale(spec, scope) {\n  const type = spec.type || 'linear';\n\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n\n  scope.addScale(spec.name, {\n    type,\n    domain: undefined\n  });\n}\n\nexport function parseScale(spec, scope) {\n  const params = scope.getScale(spec.name).params;\n  let key;\n\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v\n    : v.signal ? scope.signalRef(v.signal)\n    : error('Unsupported object: ' + stringValue(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal\n    ? scope.signalRef(v.signal)\n    : v.map(v => parseLiteral(v, scope));\n}\n\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n}\n\n// -- SCALE DOMAIN ----\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal)\n    : (isArray(domain) ? explicitDomain\n    : domain.fields ? multipleDomain\n    : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(v => parseLiteral(v, scope));\n}\n\nfunction singularDomain(domain, spec, scope) {\n  const data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n\n  return isDiscrete(spec.type)\n      ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false))\n      : isQuantile(spec.type) ? data.domainRef(scope, domain.field)\n      : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  const data = domain.data,\n        fields = domain.fields.reduce((dom, d) => {\n          d = isString(d) ? {data: data, field: d}\n            : (isArray(d) || d.signal) ? fieldRef(d, scope)\n            : d;\n          dom.push(d);\n          return dom;\n        }, []);\n\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain\n    : isQuantile(spec.type) ? quantileMultipleDomain\n    : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef(data, scope) {\n  const name = '_:vega:_' + (FIELD_REF_ID++),\n        coll = Collect({});\n\n  if (isArray(data)) {\n    coll.value = {$ingest: data};\n  } else if (data.signal) {\n    const code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {data: name, field: 'data'};\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  const sort = parseSort(domain.sort, true);\n  let a, v;\n\n  // get value counts for each domain field\n  const counts = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  });\n\n  // aggregate the results from each domain field\n  const p = {groupby: keyFieldRef, pulse: counts};\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n  a = scope.add(Aggregate(p));\n\n  // collect aggregate output\n  const c = scope.add(Collect({pulse: ref(a)}));\n\n  // extract values for combined domain\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort:  scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n\n  return ref(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';\n      else sort = {field: 'key'};\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  const values = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  });\n\n  // combine value arrays\n  return ref(scope.add(MultiValues({values: values})));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  const extents = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  });\n\n  // combine extents\n  return ref(scope.add(MultiExtent({extents: extents})));\n}\n\n// -- SCALE BINS -----\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v)\n    ? parseArray(v, scope)\n    : scope.objectProperty(v);\n}\n\n// -- SCALE NICE -----\n\nfunction parseScaleNice(nice) {\n  return isObject(nice)\n    ? {\n        interval: parseLiteral(nice.interval),\n        step: parseLiteral(nice.step)\n      }\n    : parseLiteral(nice);\n}\n\n// -- SCALE INTERPOLATION -----\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n}\n\n// -- SCALE RANGE -----\n\nfunction parseScaleRange(spec, scope, params) {\n  const config = scope.config.range;\n  let range = spec.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {range: config[range]});\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {signal: 'width'}];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type)\n        ? [0, {signal: 'height'}]\n        : [{signal: 'height'}, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme)\n      ? parseArray(range.scheme, scope)\n      : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}\n","import {error, isArray, isObject, stringValue} from 'vega-util';\n\nexport default function(proj, scope) {\n  const config = scope.config.projection || {},\n        params = {};\n\n  for (const name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter(proj[name], name, scope);\n  }\n\n  // apply projection defaults from config\n  for (const name in config) {\n    if (params[name] == null) {\n      params[name] = parseParameter(config[name], name, scope);\n    }\n  }\n\n  scope.addProjection(proj.name, params);\n}\n\nfunction parseParameter(_, name, scope) {\n  return isArray(_) ? _.map(_ => parseParameter(_, name, scope))\n    : !isObject(_) ? _\n    : _.signal ? scope.signalRef(_.signal)\n    : name === 'fit' ? _\n    : error('Unsupported parameter object: ' + stringValue(_));\n}\n","export const Top = 'top';\nexport const Left = 'left';\nexport const Right = 'right';\nexport const Bottom = 'bottom';\nexport const Center = 'center';\n\nexport const Vertical = 'vertical';\n\nexport const Start = 'start';\nexport const Middle = 'middle';\nexport const End = 'end';\n\nexport const Index  = 'index';\nexport const Label  = 'label';\nexport const Offset = 'offset';\nexport const Perc   = 'perc';\nexport const Perc2  = 'perc2';\nexport const Value  = 'value';\n\nexport const GuideLabelStyle = 'guide-label';\nexport const GuideTitleStyle = 'guide-title';\nexport const GroupTitleStyle = 'group-title';\nexport const GroupSubtitleStyle = 'group-subtitle';\n\nexport const Symbols = 'symbol';\nexport const Gradient = 'gradient';\nexport const Discrete = 'discrete';\n\nexport const Size = 'size';\nexport const Shape = 'shape';\nexport const Fill = 'fill';\nexport const Stroke = 'stroke';\nexport const StrokeWidth = 'strokeWidth';\nexport const StrokeDash = 'strokeDash';\nexport const Opacity = 'opacity';\n\n// Encoding channels supported by legends\n// In priority order of 'canonical' scale\nexport const LegendScales = [\n  Size,\n  Shape,\n  Fill,\n  Stroke,\n  StrokeWidth,\n  StrokeDash,\n  Opacity\n];\n\nexport const Skip = {\n  name: 1,\n  style: 1,\n  interactive: 1\n};\n\nexport const zero = {value: 0};\nexport const one = {value: 1};\n","export const GroupMark = 'group';\nexport const RectMark = 'rect';\nexport const RuleMark = 'rule';\nexport const SymbolMark = 'symbol';\nexport const TextMark = 'text';\n","import {GroupMark} from '../marks/marktypes';\n\nexport default function(mark) {\n  mark.type = GroupMark;\n  mark.interactive = mark.interactive || false;\n  return mark;\n}\n","import {Center, End, Left, Right, Start, Vertical} from './constants';\nimport {value} from '../../util';\nimport {isObject, stringValue} from 'vega-util';\n\nexport function lookup(spec, config) {\n  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n\n  _.isVertical = s => Vertical === value(\n    spec.direction,\n    config.direction || (s ? config.symbolDirection : config.gradientDirection)\n  );\n\n  _.gradientLength = () => value(\n    spec.gradientLength,\n    config.gradientLength || config.gradientWidth\n  );\n\n  _.gradientThickness = () => value(\n    spec.gradientThickness,\n    config.gradientThickness || config.gradientHeight\n  );\n\n  _.entryColumns = () => value(\n    spec.columns,\n    value(config.columns, +_.isVertical(true))\n  );\n\n  return _;\n}\n\nexport function getEncoding(name, encode) {\n  const v = encode && (\n    (encode.update && encode.update[name]) ||\n    (encode.enter && encode.enter[name])\n  );\n  return v && v.signal ? v : v ? v.value : null;\n}\n\nexport function getStyle(name, scope, style) {\n  const s = scope.config.style[style];\n  return s && s[name];\n}\n\nexport function anchorExpr(s, e, m) {\n  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\n}\n\nexport const alignExpr = anchorExpr(\n  stringValue(Left),\n  stringValue(Right),\n  stringValue(Center)\n);\n\nexport function tickBand(_) {\n  const v = _('tickBand');\n  let offset = _('tickOffset'),\n      band, extra;\n\n  if (!v) {\n    // if no tick band entry, fall back on other properties\n    band = _('bandPosition');\n    extra = _('tickExtra');\n  } else if (v.signal) {\n    // if signal, augment code to interpret values\n    band = {signal: `(${v.signal}) === 'extent' ? 1 : 0.5`};\n    extra = {signal: `(${v.signal}) === 'extent'`};\n    if (!isObject(offset)) {\n      offset = {signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`};\n    }\n  } else if (v === 'extent') {\n    // if constant, simply set values\n    band = 1;\n    extra = true;\n    offset = 0;\n  } else {\n    band = 0.5;\n    extra = false;\n  }\n\n  return {extra, band, offset};\n}\n\nexport function extendOffset(value, offset) {\n  return !offset ? value\n    : !value ? offset\n    : !isObject(value) ? { value, offset }\n    : Object.assign({}, value, { offset: extendOffset(value.offset, offset) });\n}\n","import {Skip} from './constants';\nimport {extendEncode} from '../encode/util';\n\nexport default function(mark, extras) {\n  if (extras) {\n    mark.name = extras.name;\n    mark.style = extras.style || mark.style;\n    mark.interactive = !!extras.interactive;\n    mark.encode = extendEncode(mark.encode, extras, Skip);\n  } else {\n    mark.interactive = false;\n  }\n  return mark;\n}\n","import {one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {RectMark} from '../marks/marktypes';\nimport {LegendGradientRole} from '../marks/roles';\nimport {extend} from 'vega-util';\n\nexport default function(spec, scale, config, userEncode) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let enter, start, stop, width, height;\n\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: one,\n      fill: {gradient: scale, start: start, stop: stop}\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n\n  addEncoders(encode, {\n    stroke:      _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, { // update\n    opacity:     _('gradientOpacity')\n  });\n\n  return guideMark({\n    type: RectMark,\n    role: LegendGradientRole,\n    encode\n  }, userEncode);\n}\n","import {Perc, Perc2, Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {RectMark} from '../marks/marktypes';\nimport {LegendBandRole} from '../marks/roles';\nimport {extend} from 'vega-util';\n\nexport default function(spec, scale, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let u, v, uu, vv, adjust = '';\n\n  vertical\n    ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-')\n    : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n\n  const enter = {\n    opacity: zero,\n    fill: {scale: scale, field: Value}\n  };\n  enter[u]  = {signal: adjust + 'datum.' + Perc, mult: length};\n  enter[v]  = zero;\n  enter[uu] = {signal: adjust + 'datum.' + Perc2, mult: length};\n  enter[vv] = encoder(thickness);\n\n  const encode = {\n    enter: enter,\n    update: extend({}, enter, {opacity: one}),\n    exit: {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:      _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, { // update\n    opacity:     _('gradientOpacity')\n  });\n\n  return guideMark({\n    type: RectMark,\n    role: LegendBandRole,\n    key:  Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n","import {\n  Bottom, Center, GuideLabelStyle, Index, Label, Left, Middle,\n  Perc, Right, Top, Value, one, zero\n} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {LegendLabelRole} from '../marks/roles';\nimport {value} from '../../util';\n\nconst alignExpr = `datum.${Perc}<=0?\"${Left}\":datum.${Perc}>=1?\"${Right}\":\"${Center}\"`,\n      baselineExpr = `datum.${Perc}<=0?\"${Bottom}\":datum.${Perc}>=1?\"${Top}\":\"${Middle}\"`;\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = encoder(_.gradientThickness()),\n        length = _.gradientLength();\n\n  let overlap = _('labelOverlap'),\n      enter, update, u, v, adjust = '';\n\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      text: {field: Label}\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  addEncoders(encode, {\n    fill:        _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font:        _('labelFont'),\n    fontSize:    _('labelFontSize'),\n    fontStyle:   _('labelFontStyle'),\n    fontWeight:  _('labelFontWeight'),\n    limit:       value(spec.labelLimit, config.gradientLabelLimit)\n  });\n\n  if (vertical) {\n    enter.align = {value: 'left'};\n    enter.baseline = update.baseline = {signal: baselineExpr};\n    u = 'y'; v = 'x'; adjust = '1-';\n  } else {\n    enter.align = update.align = {signal: alignExpr};\n    enter.baseline = {value: 'top'};\n    u = 'x'; v = 'y';\n  }\n\n  enter[u] = update[u] = {signal: adjust + 'datum.' + Perc, mult: length};\n\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n\n  overlap = overlap ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.' + Index\n  } : undefined;\n\n  // type, role, style, key, dataRef, encode, extras\n  return guideMark({\n    type:  TextMark,\n    role:  LegendLabelRole,\n    style: GuideLabelStyle,\n    key:   Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n","import {\n  GuideLabelStyle, Index, Label, LegendScales, Offset, Size, Skip,\n  Value, one, zero\n} from './constants';\nimport guideGroup from './guide-group';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder, extendEncode} from '../encode/util';\nimport {SymbolMark, TextMark} from '../marks/marktypes';\nimport {LegendLabelRole, LegendSymbolRole, ScopeRole} from '../marks/roles';\n\n// userEncode is top-level, includes entries, symbols, labels\nexport default function(spec, config, userEncode, dataRef, columns) {\n  const _ = lookup(spec, config),\n        entries = userEncode.entries,\n        interactive = !!(entries && entries.interactive),\n        name = entries ? entries.name : undefined,\n        height = _('clipHeight'),\n        symbolOffset = _('symbolOffset'),\n        valueRef = {data: 'value'},\n        xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\n        yEncode = height ? encoder(height) : {field: Size},\n        index = `datum.${Index}`,\n        ncols = `max(1, ${columns})`;\n\n  let encode, enter, update, nrows, sort;\n\n  yEncode.mult = 0.5;\n\n  // -- LEGEND SYMBOLS --\n  encode = {\n    enter:  enter = {\n      opacity: zero,\n      x: {signal: xSignal, mult: 0.5, offset: symbolOffset},\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  let baseFill = null,\n      baseStroke = null;\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n\n  addEncoders(encode, {\n    fill:             _('symbolFillColor', baseFill),\n    shape:            _('symbolType'),\n    size:             _('symbolSize'),\n    stroke:           _('symbolStrokeColor', baseStroke),\n    strokeDash:       _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth:      _('symbolStrokeWidth')\n  }, { // update\n    opacity:          _('symbolOpacity')\n  });\n\n  LegendScales.forEach(scale => {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {scale: spec[scale], field: Value};\n    }\n  });\n\n  const symbols = guideMark({\n    type: SymbolMark,\n    role: LegendSymbolRole,\n    key:  Value,\n    from: valueRef,\n    clip: height ? true : undefined,\n    encode\n  }, userEncode.symbols);\n\n  // -- LEGEND LABELS --\n  const labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n\n  encode = {\n    enter:  enter = {\n      opacity: zero,\n      x: {signal: xSignal, offset: labelOffset},\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {field: Label},\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  addEncoders(encode, {\n    align:       _('labelAlign'),\n    baseline:    _('labelBaseline'),\n    fill:        _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font:        _('labelFont'),\n    fontSize:    _('labelFontSize'),\n    fontStyle:   _('labelFontStyle'),\n    fontWeight:  _('labelFontWeight'),\n    limit:       _('labelLimit')\n  });\n\n  const labels = guideMark({\n    type:  TextMark,\n    role:  LegendLabelRole,\n    style: GuideLabelStyle,\n    key:   Value,\n    from:  valueRef,\n    encode\n  }, userEncode.labels);\n\n  // -- LEGEND ENTRY GROUPS --\n  encode = {\n    enter: {\n      noBound: {value: !height}, // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {opacity: zero},\n    update: update = {\n      opacity: one,\n      row: {signal: null},\n      column: {signal: null}\n    }\n  };\n\n  // annotate and sort groups to ensure correct ordering\n  if (_.isVertical(true)) {\n    nrows = `ceil(item.mark.items.length / ${ncols})`;\n    update.row.signal = `${index}%${nrows}`;\n    update.column.signal = `floor(${index} / ${nrows})`;\n    sort = {field: ['row', index]};\n  } else {\n    update.row.signal = `floor(${index} / ${ncols})`;\n    update.column.signal = `${index} % ${ncols}`;\n    sort = {field: index};\n  }\n  // handle zero column case (implies infinite columns)\n  update.column.signal = `(${columns})?${update.column.signal}:${index}`;\n\n  // facet legend entries into sub-groups\n  dataRef = {facet: {data: dataRef, name: 'value', groupby: Index}};\n\n  return guideGroup({\n    role:   ScopeRole,\n    from:   dataRef,\n    encode: extendEncode(encode, entries, Skip),\n    marks:  [symbols, labels],\n    name,\n    interactive,\n    sort\n  });\n}\n\nexport function legendSymbolLayout(spec, config) {\n  const _ = lookup(spec, config);\n\n  // layout parameters for legend entries\n  return {\n    align:   _('gridAlign'),\n    columns: _.entryColumns(),\n    center:  {\n      row: true,\n      column: false\n    },\n    padding: {\n      row:    _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}\n","import {GuideTitleStyle, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {alignExpr, anchorExpr, lookup} from './guide-util';\nimport {addEncoders} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {LegendTitleRole} from '../marks/roles';\n\n// expression logic for align, anchor, angle, and baseline calculation\nconst isL = 'item.orient === \"left\"',\n      isR = 'item.orient === \"right\"',\n      isLR = `(${isL} || ${isR})`,\n      isVG = `datum.vgrad && ${isLR}`,\n      baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n      alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n      exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \"left\" : ${alignExpr}`,\n      exprAnchor = `item._anchor || (${isLR} ? \"middle\" : \"start\")`,\n      exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\n      exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \"bottom\" : \"top\") : ${baseline}) : \"top\"`;\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config);\n\n  const encode = {\n    enter: {opacity: zero},\n    update: {\n      opacity: one,\n      x: {field: {group: 'padding'}},\n      y: {field: {group: 'padding'}}\n    },\n    exit: {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    orient:      _('titleOrient'),\n    _anchor:     _('titleAnchor'),\n    anchor:      {signal: exprAnchor},\n    angle:       {signal: exprAngle},\n    align:       {signal: exprAlign},\n    baseline:    {signal: exprBaseline},\n    text:        spec.title,\n    fill:        _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font:        _('titleFont'),\n    fontSize:    _('titleFontSize'),\n    fontStyle:   _('titleFontStyle'),\n    fontWeight:  _('titleFontWeight'),\n    limit:       _('titleLimit'),\n    lineHeight:  _('titleLineHeight')\n  }, { // require update\n    align:       _('titleAlign'),\n    baseline:    _('titleBaseline')\n  });\n\n  return guideMark({\n    type:  TextMark,\n    role:  LegendTitleRole,\n    style: GuideTitleStyle,\n    from:  dataRef,\n    encode\n  }, userEncode);\n}\n","import {isObject, stringValue} from 'vega-util';\n\nexport default function(clip, scope) {\n  let expr;\n\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n\n  return expr\n    ? scope.signalRef(expr)\n    : !!clip;\n}\n\nfunction param(value) {\n  return isObject(value) && value.signal\n    ? value.signal\n    : stringValue(value);\n}","import {GroupMark} from './marktypes';\nimport {MarkRole, ScopeRole} from './roles';\n\nexport default function(spec) {\n  const role = spec.role || '';\n  return (!role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title'))\n    ? role\n    : spec.type === GroupMark ? ScopeRole : (role || MarkRole);\n}\n","import role from './role';\n\nexport default function(spec) {\n  return {\n    marktype:     spec.type,\n    name:         spec.name || undefined,\n    role:         spec.role || role(spec),\n    zindex:       +spec.zindex || undefined,\n    aria:         spec.aria,\n    description:  spec.description\n  };\n}\n","export default function(spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal)\n    : spec === false ? false\n    : true;\n}\n","import {Params} from '../transforms';\nimport {entry, fieldRef, isSignal, ref} from '../util';\nimport {definition} from 'vega-dataflow';\nimport {parseExpression} from 'vega-functions';\nimport {error, extend, isArray, isString, stringValue} from 'vega-util';\n\n/**\n * Parse a data transform specification.\n */\nexport default function(spec, scope) {\n  const def = definition(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n\n  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n\n  return t;\n}\n\n/**\n * Parse all parameters of a data transform.\n */\nfunction parseParameters(def, spec, scope) {\n  const params = {},\n        n = def.params.length;\n\n  for (let i = 0; i < n; ++i) {\n    const pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n  return params;\n}\n\n/**\n * Parse a data transform parameter.\n */\nfunction parseParameter(def, spec, scope) {\n  const type = def.type,\n        value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type)\n          + ' parameter: ' + stringValue(def.name));\n    }\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !isSignal(value)\n    ? value.map(v => parameterValue(def, v, scope))\n    : parameterValue(def, value, scope);\n}\n\n/**\n * Parse a single parameter value.\n */\nfunction parameterValue(def, value, scope) {\n  const type = def.type;\n\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.')\n         : isField(type) ? scope.fieldRef(value)\n         : isCompare(type) ? scope.compareRef(value)\n         : scope.signalRef(value.signal);\n  } else {\n    const expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as)\n         : expr && outerField(value) ? fieldRef(value.field, value.as)\n         : isExpr(type) ? parseExpression(value, scope)\n         : isData(type) ? ref(scope.getData(value).values)\n         : isField(type) ? fieldRef(value)\n         : isCompare(type) ? scope.compareRef(value)\n         : value;\n  }\n}\n\n/**\n * Parse parameter for accessing an index of another data set.\n */\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\nfunction parseSubParameters(def, spec, scope) {\n  const value = spec[def.name];\n\n  if (def.array) {\n    if (!isArray(value)) { // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n    return value.map(v => parseSubParameter(def, v, scope));\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n\n/**\n * Parse a sub-parameter object.\n */\nfunction parseSubParameter(def, value, scope) {\n  const n =def.params.length;\n  let pdef;\n\n  // loop over defs to find matching key\n  for (let i = 0; i < n; ++i) {\n    pdef = def.params[i];\n    for (const k in pdef.key) {\n      if (pdef.key[k] !== value[k]) { pdef = null; break; }\n    }\n    if (pdef) break;\n  }\n  // raise error if matching key not found\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value));\n\n  // parse params, create Params transform, return ref\n  const params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n}\n\n// -- Utilities -----\n\nexport const outerExpr = _ => _ && _.expr;\n\nexport const outerField = _ => _ && _.field;\n\nexport const isData = _ => _ === 'data';\n\nexport const isExpr = _ => _ === 'expr';\n\nexport const isField = _ => _ === 'field';\n\nexport const isCompare = _ => _ === 'compare';\n","import parseTransform from '../transform';\nimport {Collect} from '../../transforms';\nimport {ref} from '../../util';\nimport {array, error, extend} from 'vega-util';\n\nexport default function(from, group, scope) {\n  let facet, key, op, dataRef, parent;\n\n  // if no source data, generate singleton datum\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  }\n\n  // if faceted, process facet specification\n  else if (facet = from.facet) {\n    if (!group) error('Only group marks can be faceted.');\n\n    // use pre-faceted source data, if available\n    if (facet.field != null) {\n      dataRef = parent = getDataRef(facet, scope);\n    } else {\n      // generate facet aggregates if no direct data specification\n      if (!from.data) {\n        op = parseTransform(extend({\n          type:    'aggregate',\n          groupby: array(facet.groupby)\n        }, facet.aggregate), scope);\n        op.params.key = scope.keyRef(facet.groupby);\n        op.params.pulse = getDataRef(facet, scope);\n        dataRef = parent = ref(scope.add(op));\n      } else {\n        parent = ref(scope.getData(from.data).aggregate);\n      }\n\n      key = scope.keyRef(facet.groupby, true);\n    }\n  }\n\n  // if not yet defined, get source data reference\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\n\nexport function getDataRef(from, scope) {\n  return from.$ref ? from\n    : from.data && from.data.$ref ? from.data\n    : ref(scope.getData(from.data).output);\n}","import {Aggregate, Collect} from './transforms';\nimport {aggrField, entry, keyFieldRef, ref, sortKey} from './util';\nimport {isString} from 'vega-util';\n\nexport default function DataScope(scope, input, output, values, aggr) {\n  this.scope = scope;   // parent scope object\n  this.input = input;   // first operator in pipeline (tuple input)\n  this.output = output; // last operator in pipeline (tuple output)\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n\n  // last aggregate in transform pipeline\n  this.aggregate = aggr;\n\n  // lookup table of field indices\n  this.index = {};\n}\n\nDataScope.fromEntries = function(scope, entries) {\n  const n = entries.length,\n        values = entries[n-1],\n        output = entries[n-2];\n\n  let input = entries[0],\n      aggr = null,\n      i = 1;\n\n  if (input && input.type === 'load') {\n    input = entries[1];\n  }\n\n  // add operator entries to this scope, wire up pulse chain\n  scope.add(entries[0]);\n  for (; i<n; ++i) {\n    entries[i].params.pulse = ref(entries[i-1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  const as = aggrField(sort.op, sort.field);\n  let s;\n\n  if (p.ops) {\n    for (let i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n  if (sort.op) {\n    p.ops.push((s=sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  const cache = ds[name] || (ds[name] = {}),\n        sort = sortKey(counts);\n\n  let k = fieldKey(field),\n      v, op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    const params = counts\n      ? {field: keyFieldRef, pulse: ds.countsRef(scope, field, counts)}\n      : {field: scope.fieldRef(field), pulse: ref(ds.output)};\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n  return v;\n}\n\nDataScope.prototype = {\n  countsRef(scope, field, sort) {\n    const ds = this,\n          cache = ds.counts || (ds.counts = {}),\n          k = fieldKey(field);\n\n    let v, a, p;\n\n    if (k != null) {\n      scope = ds.scope;\n      v = cache[k];\n    }\n\n    if (!v) {\n      p = {\n        groupby: scope.fieldRef(field, 'key'),\n        pulse: ref(ds.output)\n      };\n      if (sort && sort.field) addSortField(scope, p, sort);\n      a = scope.add(Aggregate(p));\n      v = scope.add(Collect({pulse: ref(a)}));\n      v = {agg: a, ref: ref(v)};\n      if (k != null) cache[k] = v;\n    } else if (sort && sort.field) {\n      addSortField(scope, v.agg.params, sort);\n    }\n\n    return v.ref;\n  },\n\n  tuplesRef() {\n    return ref(this.values);\n  },\n\n  extentRef(scope, field) {\n    return cache(scope, this, 'extent', 'extent', field, false);\n  },\n\n  domainRef(scope, field) {\n    return cache(scope, this, 'domain', 'values', field, false);\n  },\n\n  valuesRef(scope, field, sort) {\n    return cache(scope, this, 'vals', 'values', field, sort || true);\n  },\n\n  lookupRef(scope, field) {\n    return cache(scope, this, 'lookup', 'tupleindex', field, false);\n  },\n\n  indataRef(scope, field) {\n    return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n  }\n};\n","import {operator} from '../util';\nimport {parseExpression} from 'vega-functions';\n\nexport default function(spec, scope, name) {\n  const remove = spec.remove,\n        insert = spec.insert,\n        toggle = spec.toggle,\n        modify = spec.modify,\n        values = spec.values,\n        op = scope.add(operator());\n\n  const update = 'if(' + spec.trigger + ',modify(\"'\n    + name + '\",'\n    + [insert, remove, toggle, modify, values]\n        .map(_ => _ == null ? 'null' : _)\n        .join(',')\n    + '),0)';\n\n  const expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\n","import parseEncode from './encode';\nimport clip from './marks/clip';\nimport definition from './marks/definition';\nimport interactive from './marks/interactive';\nimport parseData from './marks/data';\nimport parseFacet from './marks/facet';\nimport parseSubflow from './marks/subflow';\nimport getRole from './marks/role';\nimport {GroupMark} from './marks/marktypes';\nimport {FrameRole, MarkRole, ScopeRole} from './marks/roles';\nimport parseTransform from './transform';\nimport parseTrigger from './trigger';\nimport DataScope from '../DataScope';\nimport {fieldRef, isSignal, ref} from '../util';\nimport {error} from 'vega-util';\nimport {Bound, Collect, DataJoin, Encode, Mark, Overlap, Render, Sieve, SortItems, ViewLayout} from '../transforms';\n\nexport default function(spec, scope) {\n  const role = getRole(spec),\n        group = spec.type === GroupMark,\n        facet = spec.from && spec.from.facet,\n        overlap = spec.overlap;\n\n  let layout = spec.layout || role === ScopeRole || role === FrameRole,\n      ops, op, store, enc, name, layoutRef, boundRef;\n\n  const nested = role === MarkRole || layout || facet;\n\n  // resolve input data\n  const input = parseData(spec.from, group, scope);\n\n  // data join to map tuples to visual items\n  op = scope.add(DataJoin({\n    key:   input.key || (spec.key ? fieldRef(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  const joinRef = ref(op);\n\n  // collect visual items\n  op = store = scope.add(Collect({pulse: joinRef}));\n\n  // connect visual items to scenegraph\n  op = scope.add(Mark({\n    markdef:     definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip:        clip(spec.clip, scope),\n    context:     {$context: true},\n    groups:      scope.lookup(),\n    parent:      scope.signals.parent ? scope.signalRef('parent') : null,\n    index:       scope.markpath(),\n    pulse:       ref(op)\n  }));\n  const markRef = ref(op);\n\n  // add visual encoders\n  op = enc = scope.add(Encode(parseEncode(\n    spec.encode, spec.type, role, spec.style, scope,\n    {mod: false, pulse: markRef}\n  )));\n\n  // monitor parent marks to propagate changes\n  op.params.parent = scope.encode();\n\n  // add post-encoding transforms, if defined\n  if (spec.transform) {\n    spec.transform.forEach(_ => {\n      const tx = parseTransform(_, scope),\n            md = tx.metadata;\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  }\n\n  // if item sort specified, perform post-encoding\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort:  scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n\n  const encodeRef = ref(op);\n\n  // add view layout operator if needed\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout:   scope.objectProperty(spec.layout),\n      legends:  scope.legends,\n      mark:     markRef,\n      pulse:    encodeRef\n    }));\n    layoutRef = ref(layout);\n  }\n\n  // compute bounding boxes\n  const bound = scope.add(Bound({mark: markRef, pulse: layoutRef || encodeRef}));\n  boundRef = ref(bound);\n\n  // if group mark, recurse to parse nested content\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) { ops = scope.operators; ops.pop(); if (layout) ops.pop(); }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input)          // explicit facet\n        : nested ? parseSubflow(spec, scope, input) // standard mark group\n        : scope.parse(spec); // guide group, we can avoid nested scopes\n    scope.popState();\n\n    if (nested) { if (layout) ops.push(layout); ops.push(bound); }\n  }\n\n  // if requested, add overlap removal transform\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  }\n\n  // render / sieve items\n  const render = scope.add(Render({pulse: boundRef})),\n        sieve = scope.add(Sieve({pulse: ref(render)}, undefined, scope.parent()));\n\n  // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(on => {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n      parseTrigger(on, scope, name);\n    });\n  }\n}\n\nfunction parseOverlap(overlap, source, scope) {\n  const method = overlap.method,\n        bound = overlap.bound,\n        sep = overlap.separation;\n\n  const params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse:  source\n  };\n\n  if (overlap.order) {\n    params.sort = scope.compareRef({field: overlap.order});\n  }\n\n  if (bound) {\n    const tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n\n  return ref(scope.add(Overlap(params)));\n}\n","import {getDataRef} from './data';\nimport DataScope from '../../DataScope';\nimport {Collect, Facet, PreFacet, Sieve} from '../../transforms';\nimport {ref} from '../../util';\nimport {error, stringValue} from 'vega-util';\n\nexport default function(spec, scope, group) {\n  const facet = spec.from.facet,\n        name = facet.name,\n        data = getDataRef(facet, scope);\n  let op;\n\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key:   scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  }\n\n  // initialize facet subscope\n  const subscope = scope.fork(),\n        source = subscope.add(Collect()),\n        values = subscope.add(Sieve({pulse: ref(source)}));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null);\n\n  // parse faceted subflow\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n","import {PreFacet, Sieve} from '../../transforms';\n\nexport default function(spec, scope, input) {\n  const op = scope.add(PreFacet({pulse: input.pulse})),\n        subscope = scope.fork();\n\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null);\n\n  // parse group mark subflow\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n","import {addEncoders, extendEncode} from './encode/util';\nimport {\n  Discrete, Gradient,\n  GuideLabelStyle, LegendScales, Skip, Symbols\n} from './guides/constants';\nimport guideGroup from './guides/guide-group';\nimport {getEncoding, getStyle, lookup} from './guides/guide-util';\nimport legendGradient from './guides/legend-gradient';\nimport legendGradientDiscrete from './guides/legend-gradient-discrete';\nimport legendGradientLabels from './guides/legend-gradient-labels';\nimport legendSymbolGroups, {legendSymbolLayout} from './guides/legend-symbol-groups';\nimport legendTitle from './guides/legend-title';\nimport parseMark from './mark';\nimport {LegendEntryRole, LegendRole} from './marks/roles';\n\nimport {deref, ref} from '../util';\nimport {Collect, LegendEntries} from '../transforms';\n\nimport {parseExpression} from 'vega-functions';\nimport {isContinuous, isDiscretizing} from 'vega-scale';\nimport {error} from 'vega-util';\n\nexport default function(spec, scope) {\n  const config = scope.config.legend,\n        encode = spec.encode || {},\n        _ = lookup(spec, config),\n        legendEncode = encode.legend || {},\n        name = legendEncode.name || undefined,\n        interactive = legendEncode.interactive,\n        style = legendEncode.style,\n        scales = {};\n\n  let scale = 0, entryLayout, params, children;\n\n  // resolve scales and 'canonical' scale name\n  LegendScales.forEach(s => spec[s]\n    ? (scales[s] = spec[s], scale = scale || spec[s]) : 0\n  );\n  if (!scale) error('Missing valid scale for legend.');\n\n  // resolve legend type (symbol, gradient, or discrete gradient)\n  const type = legendType(spec, scope.scaleType(scale));\n\n  // single-element data source for legend group\n  const datum = {\n    title:  spec.title != null,\n    scales: scales,\n    type:   type,\n    vgrad:  type !== 'symbol' &&  _.isVertical()\n  };\n  const dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // encoding properties for legend entry sub-group\n  const entryEncode = {enter: {x: {value: 0}, y: {value: 0}}};\n\n  // data source for legend values\n  const entryRef = ref(scope.add(LegendEntries(params = {\n    type:    type,\n    scale:   scope.scaleRef(scale),\n    count:   scope.objectProperty(_('tickCount')),\n    limit:   scope.property(_('symbolLimit')),\n    values:  scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // continuous gradient legend\n  if (type === Gradient) {\n    children = [\n      legendGradient(spec, scale, config, encode.gradient),\n      legendGradientLabels(spec, config, encode.labels, entryRef)\n    ];\n    // adjust default tick count based on the gradient length\n    params.count = params.count || scope.signalRef(\n      `max(2,2*floor((${deref(_.gradientLength())})/100))`\n    );\n  }\n\n  // discrete gradient legend\n  else if (type === Discrete) {\n    children = [\n      legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef),\n      legendGradientLabels(spec, config, encode.labels, entryRef)\n    ];\n  }\n\n  // symbol legend\n  else {\n    // determine legend symbol group layout\n    entryLayout = legendSymbolLayout(spec, config);\n    children = [\n      legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))\n    ];\n    // pass symbol size information to legend entry generator\n    params.size = sizeExpression(spec, scope, children[0].marks);\n  }\n\n  // generate legend marks\n  children = [\n    guideGroup({\n      role: LegendEntryRole,\n      from: dataRef,\n      encode: entryEncode,\n      marks: children,\n      layout: entryLayout,\n      interactive\n    })\n  ];\n\n  // include legend title if defined\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  }\n\n  // parse legend specification\n  return parseMark(\n    guideGroup({\n      role:        LegendRole,\n      from:        dataRef,\n      encode:      extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n      marks:       children,\n      aria:        _('aria'),\n      description: _('description'),\n      zindex:      _('zindex'),\n      name,\n      interactive,\n      style\n    }),\n    scope\n  );\n}\n\nfunction legendType(spec, scaleType) {\n  let type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient\n      : isDiscretizing(scaleType) ? Discrete\n      : Symbols;\n  }\n\n  return type !== Gradient ? type\n    : isDiscretizing(scaleType) ? Discrete\n    : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n}\n\nfunction buildLegendEncode(_, spec, config) {\n  const encode = {enter: {}, update: {}};\n\n  addEncoders(encode, {\n    orient:       _('orient'),\n    offset:       _('offset'),\n    padding:      _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill:         _('fillColor'),\n    stroke:       _('strokeColor'),\n    strokeWidth:  config.strokeWidth,\n    strokeDash:   config.strokeDash,\n    x:            _('legendX'),\n    y:            _('legendY'),\n\n    // accessibility support\n    format:       spec.format,\n    formatType:   spec.formatType\n  });\n\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  const size = deref(getChannel('size', spec, marks)),\n        strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n        fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n\n  return parseExpression(\n    `max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`,\n    scope\n  );\n}\n\nfunction getChannel(name, spec, marks) {\n  return spec[name]\n    ? `scale(\"${spec[name]}\",datum)`\n    : getEncoding(name, marks[0].encode);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\n","import {addEncoders, extendEncode} from './encode/util';\nimport {GroupSubtitleStyle, GroupTitleStyle, Left, Right, Skip} from './guides/constants';\nimport guideGroup from './guides/guide-group';\nimport guideMark from './guides/guide-mark';\nimport {alignExpr, lookup} from './guides/guide-util';\nimport parseMark from './mark';\nimport {TextMark} from './marks/marktypes';\nimport {TitleRole, TitleSubtitleRole, TitleTextRole} from './marks/roles';\nimport {Collect} from '../transforms';\nimport {ref} from '../util';\nimport {extend, isString} from 'vega-util';\n\nconst angleExpr = `item.orient===\"${Left}\"?-90:item.orient===\"${Right}\"?90:0`;\n\nexport default function(spec, scope) {\n  spec = isString(spec) ? {text: spec} : spec;\n\n  const _ = lookup(spec, scope.config.title),\n        encode = spec.encode || {},\n        userEncode = encode.group || {},\n        name = userEncode.name || undefined,\n        interactive = userEncode.interactive,\n        style = userEncode.style,\n        children = [];\n\n  // single-element data source for group title\n  const datum = {},\n        dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // include title text\n  children.push(buildTitle(spec, _, titleEncode(spec), dataRef));\n\n  // include subtitle text\n  if (spec.subtitle) {\n    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n  }\n\n  // parse title specification\n  return parseMark(\n    guideGroup({\n      role:        TitleRole,\n      from:        dataRef,\n      encode:      groupEncode(_, userEncode),\n      marks:       children,\n      aria:        _('aria'),\n      description: _('description'),\n      zindex:      _('zindex'),\n      name,\n      interactive,\n      style\n    }),\n    scope\n  );\n}\n\n// provide backwards-compatibility for title custom encode;\n// the top-level encode block has been *deprecated*.\nfunction titleEncode(spec) {\n  const encode = spec.encode;\n  return (encode && encode.title) || extend({\n    name: spec.name,\n    interactive: spec.interactive,\n    style: spec.style\n  }, encode);\n}\n\nfunction groupEncode(_, userEncode) {\n  const encode = {enter: {}, update: {}};\n\n  addEncoders(encode, {\n    orient:      _('orient'),\n    anchor:      _('anchor'),\n    align:       {signal: alignExpr},\n    angle:       {signal: angleExpr},\n    limit:       _('limit'),\n    frame:       _('frame'),\n    offset:      _('offset') || 0,\n    padding:     _('subtitlePadding')\n  });\n\n  return extendEncode(encode, userEncode, Skip);\n}\n\nfunction buildTitle(spec, _, userEncode, dataRef) {\n  const zero = {value: 0},\n        text = spec.text,\n        encode = {\n          enter: {opacity: zero},\n          update: {opacity: {value: 1}},\n          exit: {opacity: zero}\n        };\n\n  addEncoders(encode, {\n    text:       text,\n    align:      {signal: 'item.mark.group.align'},\n    angle:      {signal: 'item.mark.group.angle'},\n    limit:      {signal: 'item.mark.group.limit'},\n    baseline:   'top',\n    dx:         _('dx'),\n    dy:         _('dy'),\n    fill:       _('color'),\n    font:       _('font'),\n    fontSize:   _('fontSize'),\n    fontStyle:  _('fontStyle'),\n    fontWeight: _('fontWeight'),\n    lineHeight: _('lineHeight')\n  }, { // update\n    align:      _('align'),\n    angle:      _('angle'),\n    baseline:   _('baseline')\n  });\n\n  return guideMark({\n    type: TextMark,\n    role: TitleTextRole,\n    style: GroupTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction buildSubTitle(spec, _, userEncode, dataRef) {\n  const zero = {value: 0},\n        text = spec.subtitle,\n        encode = {\n          enter: {opacity: zero},\n          update: {opacity: {value: 1}},\n          exit: {opacity: zero}\n        };\n\n  addEncoders(encode, {\n    text:       text,\n    align:      {signal: 'item.mark.group.align'},\n    angle:      {signal: 'item.mark.group.angle'},\n    limit:      {signal: 'item.mark.group.limit'},\n    baseline:   'top',\n    dx:         _('dx'),\n    dy:         _('dy'),\n    fill:       _('subtitleColor'),\n    font:       _('subtitleFont'),\n    fontSize:   _('subtitleFontSize'),\n    fontStyle:  _('subtitleFontStyle'),\n    fontWeight: _('subtitleFontWeight'),\n    lineHeight: _('subtitleLineHeight')\n  }, { // update\n    align:      _('align'),\n    angle:      _('angle'),\n    baseline:   _('baseline')\n  });\n\n  return guideMark({\n    type:  TextMark,\n    role:  TitleSubtitleRole,\n    style: GroupSubtitleStyle,\n    from:  dataRef,\n    encode\n  }, userEncode);\n}\n","import parseTransform from './transform';\nimport parseTrigger from './trigger';\nimport {Collect, Load, Relay, Sieve} from '../transforms';\nimport {hasSignal, isSignal, ref} from '../util';\nimport {array} from 'vega-util';\n\nexport default function parseData(data, scope) {\n  const transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(tx => {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(on => {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n\n/**\n * Analyze a data pipeline, add needed operators.\n */\nfunction analyze(data, scope, ops) {\n  const output = [];\n  let source = null,\n      modify = false,\n      generate = false,\n      upstream, i, n, t, m;\n\n  if (data.values) {\n    // hard-wired input data set\n    if (isSignal(data.values) || hasSignal(data.format)) {\n      // if either values is signal or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source)\n      .map(d => ref(scope.getData(d).output));\n    output.push(null); // populate later\n  }\n\n  // scan data transforms, add collectors as needed\n  for (i=0, n=ops.length; i<n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n    output.push(t);\n\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n\n    if (m.source) source = t;\n    else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\n\nfunction collect(values) {\n  const s = Collect({}, values);\n  s.metadata = {source: true};\n  return s;\n}\n\nfunction load(scope, data) {\n  return Load({\n    url:    data.url ? scope.property(data.url) : undefined,\n    async:  data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\n","import {extend, stringValue} from 'vega-util';\nimport {Bottom, Left, Right, Top} from './constants';\nimport {encoder} from '../encode/util';\nimport {isSignal} from '../../util';\n\nconst isX = orient => orient === Bottom || orient === Top;\n\n// get sign coefficient based on axis orient\nexport const getSign = (orient, a, b) => isSignal(orient)\n  ? ifLeftTopExpr(orient.signal, a, b)\n  : orient === Left || orient === Top ? a : b;\n\n// condition on axis x-direction\nexport const ifX = (orient, a, b) => isSignal(orient)\n  ? ifXEnc(orient.signal, a, b)\n  : isX(orient) ? a : b;\n\n// condition on axis y-direction\nexport const ifY = (orient, a, b) => isSignal(orient)\n  ? ifYEnc(orient.signal, a, b)\n  : isX(orient) ? b : a;\n\nexport const ifTop = (orient, a, b) => isSignal(orient)\n  ? ifTopExpr(orient.signal, a, b)\n  : orient === Top ? {value: a} : {value: b};\n\nexport const ifRight = (orient, a, b) => isSignal(orient)\n  ? ifRightExpr(orient.signal, a, b)\n  : orient === Right ? {value: a} : {value: b};\n\nconst ifXEnc = ($orient, a, b) => ifEnc(\n  `${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b\n);\n\nconst ifYEnc = ($orient, a, b) => ifEnc(\n  `${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b\n);\n\nconst ifLeftTopExpr = ($orient, a, b) => ifExpr(\n  `${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b\n);\n\nconst ifTopExpr = ($orient, a, b) => ifExpr(\n  `${$orient} === '${Top}'`, a, b\n);\n\nconst ifRightExpr = ($orient, a, b) => ifExpr(\n  `${$orient} === '${Right}'`, a, b\n);\n\nconst ifEnc = (test, a, b) => {\n  // ensure inputs are encoder objects (or null)\n  a = a != null ? encoder(a) : a;\n  b = b != null ? encoder(b) : b;\n\n  if (isSimple(a) && isSimple(b)) {\n    // if possible generate simple signal expression\n    a = a ? (a.signal || stringValue(a.value)) : null;\n    b = b ? (b.signal || stringValue(b.value)) : null;\n    return {signal: `${test} ? (${a}) : (${b})`};\n  } else {\n    // otherwise generate rule set\n    return [extend({test}, a)].concat(b || []);\n  }\n};\n\nconst isSimple = enc => (\n  enc == null || Object.keys(enc).length === 1\n);\n\nconst ifExpr = (test, a, b) => ({\n  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\n});\n\nexport const ifOrient = ($orient, t, b, l, r) => ({\n  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '')\n        + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '')\n        + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '')\n        + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '')\n        + '(null)'\n});\n\nconst toExpr = v => isSignal(v)\n  ? v.signal\n  : v == null ? null : stringValue(v);\n\nexport const mult = (sign, value) => value === 0 ? 0 : isSignal(sign)\n  ? {signal: `(${sign.signal}) * ${value}`}\n  : {value: sign * value};\n\nexport const patch = (value, base) => {\n  const s = value.signal;\n  return s && s.endsWith('(null)')\n    ? {signal: s.slice(0, -6) + base.signal}\n    : value;\n};\n","import {ifOrient, ifX} from './axis-util';\nimport {Bottom, GuideLabelStyle, GuideTitleStyle, Top} from './constants';\nimport {isSignal} from '../../util';\nimport {extend, hasOwnProperty} from 'vega-util';\n\nfunction fallback(prop, config, axisConfig, style) {\n  let styleProp;\n\n  if (config && hasOwnProperty(config, prop)) {\n    return config[prop];\n  }\n  else if (hasOwnProperty(axisConfig, prop)) {\n    return axisConfig[prop];\n  }\n  else if (prop.startsWith('title')) {\n    switch (prop) {\n      case 'titleColor':\n        styleProp = 'fill';\n        break;\n      case 'titleFont':\n      case 'titleFontSize':\n      case 'titleFontWeight':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n    return style[GuideTitleStyle][styleProp];\n  }\n  else if (prop.startsWith('label')) {\n    switch (prop) {\n      case 'labelColor':\n        styleProp = 'fill';\n        break;\n      case 'labelFont':\n      case 'labelFontSize':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n    return style[GuideLabelStyle][styleProp];\n  }\n\n  return null;\n}\n\nfunction keys(objects) {\n  const map = {};\n  for (const obj of objects) {\n    if (!obj) continue;\n    for (const key in obj) map[key] = 1;\n  }\n  return Object.keys(map);\n}\n\nexport default function(spec, scope) {\n  var config = scope.config,\n      style = config.style,\n      axis = config.axis,\n      band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n      orient = spec.orient,\n      xy, or, key;\n\n  if (isSignal(orient)) {\n    const xyKeys = keys([\n            config.axisX, config.axisY\n          ]),\n          orientKeys = keys([\n            config.axisTop, config.axisBottom,\n            config.axisLeft, config.axisRight\n          ]);\n\n    xy = {};\n    for (key of xyKeys) {\n      xy[key] = ifX(\n        orient,\n        fallback(key, config.axisX, axis, style),\n        fallback(key, config.axisY, axis, style)\n      );\n    }\n\n    or = {};\n    for (key of orientKeys) {\n      or[key] = ifOrient(\n        orient.signal,\n        fallback(key, config.axisTop, axis, style),\n        fallback(key, config.axisBottom, axis, style),\n        fallback(key, config.axisLeft, axis, style),\n        fallback(key, config.axisRight, axis, style)\n      );\n    }\n  } else {\n    xy = (orient === Top || orient === Bottom) ? config.axisX : config.axisY;\n    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n  }\n\n  const result = (xy || or || band)\n    ? extend({}, axis, xy, or, band)\n    : axis;\n\n  return result;\n}\n","import {ifX, ifY} from './axis-util';\nimport {one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders} from '../encode/util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisDomainRole} from '../marks/roles';\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient;\n\n  let enter, update;\n  const encode = {\n    enter: enter = {opacity: zero},\n    update: update = {opacity: one},\n    exit: {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:           _('domainColor'),\n    strokeCap:        _('domainCap'),\n    strokeDash:       _('domainDash'),\n    strokeDashOffset: _('domainDashOffset'),\n    strokeWidth:      _('domainWidth'),\n    strokeOpacity:    _('domainOpacity')\n  });\n\n  const pos0 = position(spec, 0);\n  const pos1 = position(spec, 1);\n\n  enter.x = update.x = ifX(orient, pos0, zero);\n  enter.x2 = update.x2 = ifX(orient, pos1);\n\n  enter.y = update.y = ifY(orient, pos0, zero);\n  enter.y2 = update.y2 = ifY(orient, pos1);\n\n  return guideMark({\n    type: RuleMark,\n    role: AxisDomainRole,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction position(spec, pos) {\n  return {scale: spec.scale, range: pos};\n}\n","import {getSign, ifX, ifY} from './axis-util';\nimport {Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders} from '../encode/util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisGridRole} from '../marks/roles';\nimport {isSignal} from '../../util';\nimport {extend, isObject} from 'vega-util';\n\nexport default function(spec, config, userEncode, dataRef, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        vscale = spec.gridScale,\n        sign = getSign(orient, 1, -1),\n        offset = offsetValue(spec.offset, sign);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {opacity: zero},\n    update: update = {opacity: one},\n    exit: exit = {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:           _('gridColor'),\n    strokeCap:        _('gridCap'),\n    strokeDash:       _('gridDash'),\n    strokeDashOffset: _('gridDashOffset'),\n    strokeOpacity:    _('gridOpacity'),\n    strokeWidth:      _('gridWidth')\n  });\n\n  const tickPos = {\n    scale:  spec.scale,\n    field:  Value,\n    band:   band.band,\n    extra:  band.extra,\n    offset: band.offset,\n    round:  _('tickRound')\n  };\n\n  const sz = ifX(orient, {signal: 'height'}, {signal: 'width'});\n\n  const gridStart = vscale\n    ? {scale: vscale, range: 0, mult: sign, offset: offset}\n    : {value: 0, offset: offset};\n\n  const gridEnd = vscale\n    ? {scale: vscale, range: 1, mult: sign, offset: offset}\n    : extend(sz, {mult: sign, offset: offset});\n\n  enter.x = update.x = ifX(orient, tickPos, gridStart);\n  enter.y = update.y = ifY(orient, tickPos, gridStart);\n  enter.x2 = update.x2 = ifY(orient, gridEnd);\n  enter.y2 = update.y2 = ifX(orient, gridEnd);\n  exit.x = ifX(orient, tickPos);\n  exit.y = ifY(orient, tickPos);\n\n  return guideMark({\n    type: RuleMark,\n    role: AxisGridRole,\n    key:  Value,\n    from: dataRef,\n    encode\n   }, userEncode);\n}\n\nfunction offsetValue(offset, sign)  {\n  if (sign === 1) {\n    // no further adjustment needed, just return offset\n  } else if (!isObject(offset)) {\n    offset = isSignal(sign)\n      ? {signal: `(${sign.signal}) * (${offset || 0})`}\n      : sign * (offset || 0);\n  } else {\n    let entry = offset = extend({}, offset);\n    while (entry.mult != null) {\n      if (!isObject(entry.mult)) {\n        entry.mult = isSignal(sign) // no offset if sign === 1\n          ? {signal: `(${entry.mult}) * (${sign.signal})`}\n          : entry.mult * sign;\n        return offset;\n      } else {\n        entry = entry.mult = extend({}, entry.mult);\n      }\n    }\n    entry.mult = sign;\n  }\n\n  return offset;\n}\n","import {getSign, ifRight, ifTop, ifX, ifY, patch} from './axis-util';\nimport {GuideLabelStyle, Label, Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {extendOffset, lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {AxisLabelRole} from '../marks/roles';\nimport {deref} from '../../util';\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), '\n      + 'scale(\"' + scale + '\", datum.value), '\n      + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\n\nexport default function(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        scale = spec.scale,\n        sign = getSign(orient, -1, 1),\n        flush = deref(_('labelFlush')),\n        flushOffset = deref(_('labelFlushOffset')),\n        labelAlign = _('labelAlign'),\n        labelBaseline = _('labelBaseline');\n\n  let flushOn = flush === 0 || !!flush,\n      update;\n\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n\n  const tickPos = {\n    scale:  scale,\n    field:  Value,\n    band:   0.5,\n    offset: extendOffset(band.offset, _('labelOffset'))\n  };\n\n  const align = ifX(orient,\n    flushOn\n      ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"')\n      : {value: 'center'},\n    ifRight(orient, 'left', 'right')\n  );\n\n  const baseline = ifX(orient,\n    ifTop(orient, 'bottom', 'top'),\n    flushOn\n      ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"')\n      : {value: 'middle'}\n  );\n\n  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\n  flushOn = flushOn && flushOffset;\n\n  const enter = {\n    opacity: zero,\n    x: ifX(orient, tickPos, tickSize),\n    y: ifY(orient, tickPos, tickSize)\n  };\n\n  const encode = {\n    enter: enter,\n    update: update = {\n      opacity: one,\n      text: {field: Label},\n      x: enter.x,\n      y: enter.y,\n      align,\n      baseline\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n\n  addEncoders(encode, {\n    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n  });\n\n  addEncoders(encode, {\n    angle:       _('labelAngle'),\n    fill:        _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font:        _('labelFont'),\n    fontSize:    _('labelFontSize'),\n    fontWeight:  _('labelFontWeight'),\n    fontStyle:   _('labelFontStyle'),\n    limit:       _('labelLimit'),\n    lineHeight:  _('labelLineHeight')\n  }, {\n    align:       labelAlign,\n    baseline:    labelBaseline\n  });\n\n  const bound   = _('labelBound');\n  let overlap = _('labelOverlap');\n\n  // if overlap method or bound defined, request label overlap removal\n  overlap = overlap || bound ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.index',\n    bound: bound ? {scale, orient, tolerance: bound} : null\n  } : undefined;\n\n  if (update.align !== align) {\n    update.align = patch(update.align, align);\n  }\n  if (update.baseline !== baseline) {\n    update.baseline = patch(update.baseline, baseline);\n  }\n\n  return guideMark({\n    type:  TextMark,\n    role:  AxisLabelRole,\n    style: GuideLabelStyle,\n    key:   Value,\n    from:  dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n","import {getSign, ifTop, ifX, ifY, mult, patch} from './axis-util';\nimport {Bottom, GuideTitleStyle, Top, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {alignExpr, anchorExpr, lookup} from './guide-util';\nimport {addEncoders, encoder, has} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {AxisTitleRole} from '../marks/roles';\nimport {extend} from 'vega-util';\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      anchor: encoder(_('titleAnchor', null)),\n      align: {signal: alignExpr}\n    },\n    update: update = extend({}, enter, {\n      opacity: one,\n      text: encoder(spec.title)\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n\n  const titlePos = {\n    signal: `lerp(range(\"${spec.scale}\"), ${anchorExpr(0, 1, 0.5)})`\n  };\n\n  update.x = ifX(orient, titlePos);\n  update.y = ifY(orient, titlePos);\n  enter.angle = ifX(orient, zero, mult(sign, 90));\n  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {value: Bottom});\n  update.angle = enter.angle;\n  update.baseline = enter.baseline;\n\n  addEncoders(encode, {\n    fill:        _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font:        _('titleFont'),\n    fontSize:    _('titleFontSize'),\n    fontStyle:   _('titleFontStyle'),\n    fontWeight:  _('titleFontWeight'),\n    limit:       _('titleLimit'),\n    lineHeight:  _('titleLineHeight')\n  }, { // require update\n    align:       _('titleAlign'),\n    angle:       _('titleAngle'),\n    baseline:    _('titleBaseline')\n  });\n\n  autoLayout(_, orient, encode, userEncode);\n  encode.update.align = patch(encode.update.align, enter.align);\n  encode.update.angle = patch(encode.update.angle, enter.angle);\n  encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n\n  return guideMark({\n    type:  TextMark,\n    role:  AxisTitleRole,\n    style: GuideTitleStyle,\n    from:  dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction autoLayout(_, orient, encode, userEncode) {\n  const auto = (value, dim) => value != null\n    ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false)\n    : !has(dim, userEncode) ? true : false;\n\n  const autoY = auto(_('titleX'), 'x'),\n        autoX = auto(_('titleY'), 'y');\n\n  encode.enter.auto = autoX === autoY\n    ? encoder(autoX)\n    : ifX(orient, encoder(autoX), encoder(autoY));\n}\n","import {addEncoders, extendEncode} from './encode/util';\nimport axisConfig from './guides/axis-config';\nimport axisDomain from './guides/axis-domain';\nimport axisGrid from './guides/axis-grid';\nimport axisTicks from './guides/axis-ticks';\nimport axisLabels from './guides/axis-labels';\nimport axisTitle from './guides/axis-title';\nimport {Skip} from './guides/constants';\nimport guideGroup from './guides/guide-group';\nimport {lookup, tickBand} from './guides/guide-util';\nimport {AxisRole} from './marks/roles';\nimport parseMark from './mark';\nimport {AxisTicks, Collect} from '../transforms';\nimport {ref, value} from '../util';\n\nexport default function(spec, scope) {\n  const config = axisConfig(spec, scope),\n        encode = spec.encode || {},\n        axisEncode = encode.axis || {},\n        name = axisEncode.name || undefined,\n        interactive = axisEncode.interactive,\n        style = axisEncode.style,\n        _ = lookup(spec, config),\n        band = tickBand(_);\n\n  // single-element data source for axis group\n  const datum = {\n    scale:  spec.scale,\n    ticks:  !!_('ticks'),\n    labels: !!_('labels'),\n    grid:   !!_('grid'),\n    domain: !!_('domain'),\n    title:  spec.title != null\n  };\n  const dataRef = ref(scope.add(Collect({}, [datum])));\n\n  // data source for axis ticks\n  const ticksRef = ref(scope.add(AxisTicks({\n    scale:   scope.scaleRef(spec.scale),\n    extra:   scope.property(band.extra),\n    count:   scope.objectProperty(spec.tickCount),\n    values:  scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // generate axis marks\n  const children = [];\n  let size;\n\n  // include axis gridlines if requested\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  }\n\n  // include axis ticks if requested\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  }\n\n  // include axis labels if requested\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  }\n\n  // include axis domain path if requested\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  }\n\n  // include axis title if defined\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  }\n\n  // parse axis specification\n  return parseMark(\n    guideGroup({\n      role:        AxisRole,\n      from:        dataRef,\n      encode:      extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n      marks:       children,\n      aria:        _('aria'),\n      description: _('description'),\n      zindex:      _('zindex'),\n      name,\n      interactive,\n      style\n    }),\n    scope\n  );\n}\n\nfunction buildAxisEncode(_, spec) {\n  const encode = {enter: {}, update: {}};\n\n  addEncoders(encode, {\n    orient:       _('orient'),\n    offset:       _('offset') || 0,\n    position:     value(spec.position, 0),\n    titlePadding: _('titlePadding'),\n    minExtent:    _('minExtent'),\n    maxExtent:    _('maxExtent'),\n    range:        {signal: `abs(span(range(\"${spec.scale}\")))`},\n    translate:    _('translate'),\n\n    // accessibility support\n    format:       spec.format,\n    formatType:   spec.formatType\n  });\n\n  return encode;\n}\n","import {getSign, ifX, ifY} from './axis-util';\nimport {Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisTickRole} from '../marks/roles';\n\nexport default function(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {opacity: zero},\n    update: update = {opacity: one},\n    exit: exit = {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:           _('tickColor'),\n    strokeCap:        _('tickCap'),\n    strokeDash:       _('tickDash'),\n    strokeDashOffset: _('tickDashOffset'),\n    strokeOpacity:    _('tickOpacity'),\n    strokeWidth:      _('tickWidth')\n  });\n\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n\n  const tickPos = {\n    scale:  spec.scale,\n    field:  Value,\n    band:   band.band,\n    extra:  band.extra,\n    offset: band.offset,\n    round:  _('tickRound')\n  };\n\n  update.y = enter.y = ifX(orient, zero, tickPos);\n  update.y2 = enter.y2 = ifX(orient, tickSize);\n  exit.x = ifX(orient, tickPos);\n\n  update.x = enter.x = ifY(orient, zero, tickPos);\n  update.x2 = enter.x2 = ifY(orient, tickSize);\n  exit.y = ifY(orient, tickPos);\n\n  return guideMark({\n    type: RuleMark,\n    role: AxisTickRole,\n    key:  Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n","import parseSignalUpdates from './signal-updates';\nimport {initScale, parseScale} from './scale';\nimport parseProjection from './projection';\nimport parseLegend from './legend';\nimport parseSignal from './signal';\nimport parseTitle from './title';\nimport parseData from './data';\nimport parseMark from './mark';\nimport parseAxis from './axis';\nimport {array} from 'vega-util';\n\nexport default function(spec, scope, preprocessed) {\n  const signals = array(spec.signals),\n        scales = array(spec.scales);\n\n  // parse signal definitions, if not already preprocessed\n  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope));\n\n  // parse cartographic projection definitions\n  array(spec.projections).forEach(_ => parseProjection(_, scope));\n\n  // initialize scale references\n  scales.forEach(_ => initScale(_, scope));\n\n  // parse data sources\n  array(spec.data).forEach(_ => parseData(_, scope));\n\n  // parse scale definitions\n  scales.forEach(_ => parseScale(_, scope));\n\n  // parse signal updates\n  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope));\n\n  // parse axis definitions\n  array(spec.axes).forEach(_ => parseAxis(_, scope));\n\n  // parse mark definitions\n  array(spec.marks).forEach(_ => parseMark(_, scope));\n\n  // parse legend definitions\n  array(spec.legends).forEach(_ => parseLegend(_, scope));\n\n  // parse title, if defined\n  if (spec.title) parseTitle(spec.title, scope);\n\n  // parse collected lambda (anonymous) expressions\n  scope.parseLambdas();\n\n  return scope;\n}\n","import parseAutosize from './autosize';\nimport parsePadding from './padding';\nimport parseEncode from './encode';\nimport parseSignal from './signal';\nimport parseSpec from './scope';\nimport {extendEncode} from './encode/util';\nimport {GroupMark} from './marks/marktypes';\nimport {FrameRole} from './marks/roles';\nimport {operator, ref, value} from '../util';\nimport DataScope from '../DataScope';\nimport {Bound, Collect, Encode, Render, Sieve, ViewLayout} from '../transforms';\nimport {array, extend, hasOwnProperty} from 'vega-util';\n\nconst rootEncode = spec => extendEncode(\n  {\n    enter: {\n      x: {value: 0},\n      y: {value: 0}\n    },\n    update: {\n      width: {signal: 'width'},\n      height: {signal: 'height'}\n    }\n  },\n  spec\n);\n\nexport default function parseView(spec, scope) {\n  const config = scope.config;\n\n  // add scenegraph root\n  const root = ref(scope.root = scope.add(operator()));\n\n  // parse top-level signal definitions\n  const signals = collectSignals(spec, config);\n  signals.forEach(_ => parseSignal(_, scope));\n\n  // assign description, event, legend, and locale configuration\n  scope.description = spec.description || config.description;\n  scope.eventConfig = config.events;\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n  scope.locale = config.locale;\n\n  // store root group item\n  const input = scope.add(Collect());\n\n  // encode root group item\n  const encode = scope.add(Encode(parseEncode(\n    rootEncode(spec.encode), GroupMark, FrameRole,\n    spec.style, scope, {pulse: ref(input)}\n  )));\n\n  // perform view layout\n  const parent = scope.add(ViewLayout({\n    layout:   scope.objectProperty(spec.layout),\n    legends:  scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark:     root,\n    pulse:    ref(encode)\n  }));\n  scope.operators.pop();\n\n  // parse remainder of specification\n  scope.pushState(ref(encode), ref(parent), null);\n  parseSpec(spec, scope, signals);\n  scope.operators.push(parent);\n\n  // bound / render / sieve root item\n  let op = scope.add(Bound({mark: root, pulse: ref(parent)}));\n  op = scope.add(Render({pulse: ref(op)}));\n  op = scope.add(Sieve({pulse: ref(op)}));\n\n  // track metadata for root item\n  scope.addData('root', new DataScope(scope, input, input, op));\n\n  return scope;\n}\n\nfunction signalObject(name, value) {\n  return value && value.signal\n    ? { name, update: value.signal }\n    : { name, value };\n}\n\n/**\n * Collect top-level signals, merging values as needed. Signals\n * defined in the config signals arrays are added only if that\n * signal is not explicitly defined in the specification.\n * Built-in signals (autosize, background, padding, width, height)\n * receive special treatment. They are initialized using the\n * top-level spec property, or, if undefined in the spec, using\n * the corresponding top-level config property. If this property\n * is a signal reference object, the signal expression maps to the\n * signal 'update' property. If the spec's top-level signal array\n * contains an entry that matches a built-in signal, that entry\n * will be merged with the built-in specification, potentially\n * overwriting existing 'value' or 'update' properties.\n */\nfunction collectSignals(spec, config) {\n  const _ = name => value(spec[name], config[name]),\n        signals = [\n          signalObject('background', _('background')),\n          signalObject('autosize', parseAutosize(_('autosize'))),\n          signalObject('padding', parsePadding(_('padding'))),\n          signalObject('width', _('width') || 0),\n          signalObject('height', _('height') || 0)\n        ],\n        pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n        map = {};\n\n  // add spec signal array\n  array(spec.signals).forEach(s => {\n    if (hasOwnProperty(pre, s.name)) {\n      // merge if built-in signal\n      s = extend(pre[s.name], s);\n    } else {\n      // otherwise add to signal list\n      signals.push(s);\n    }\n    map[s.name] = s;\n  });\n\n  // add config signal array\n  array(config.signals).forEach(s => {\n    if (!hasOwnProperty(map, s.name) && !hasOwnProperty(pre, s.name)) {\n      // add to signal list if not already defined\n      signals.push(s);\n    }\n  });\n\n  return signals;\n}\n","import DataScope from './DataScope';\n\nimport {\n  Compare, Expression, Field, Key, Projection, Proxy, Scale, Sieve\n} from './transforms';\n\nimport {\n  Ascending, Entry, aggrField, compareRef, fieldRef, isExpr,\n  isSignal, keyRef, operator, ref\n} from './util';\n\nimport parseScope from './parsers/scope';\nimport {parseExpression} from 'vega-functions';\n\nimport {\n  array, error, extend, hasOwnProperty,\n  isArray, isObject, isString, peek, stringValue\n} from 'vega-util';\n\nexport default function Scope(config, options) {\n  this.config = config || {};\n  this.options = options || {};\n\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.eventConfig = null;\n  this.locale = null;\n\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\n\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.options = scope.options;\n  this.legends = scope.legends;\n\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\n\nScope.prototype = Subscope.prototype = {\n  parse(spec) {\n    return parseScope(spec, this);\n  },\n\n  fork() {\n    return new Subscope(this);\n  },\n\n  isSubscope() {\n    return this._subid > 0;\n  },\n\n  toRuntime() {\n    this.finish();\n    return {\n      description: this.description,\n      operators:   this.operators,\n      streams:     this.streams,\n      updates:     this.updates,\n      bindings:    this.bindings,\n      eventConfig: this.eventConfig,\n      locale:      this.locale\n    };\n  },\n\n  id() {\n    return (this._subid ? this._subid + ':' : 0) + this._id++;\n  },\n\n  add(op) {\n    this.operators.push(op);\n    op.id = this.id();\n    // if pre-registration references exist, resolve them now\n    if (op.refs) {\n      op.refs.forEach(ref => { ref.$ref = op.id; });\n      op.refs = null;\n    }\n    return op;\n  },\n\n  proxy(op) {\n    const vref = op instanceof Entry ? ref(op) : op;\n    return this.add(Proxy({value: vref}));\n  },\n\n  addStream(stream) {\n    this.streams.push(stream);\n    stream.id = this.id();\n    return stream;\n  },\n\n  addUpdate(update) {\n    this.updates.push(update);\n    return update;\n  },\n\n  // Apply metadata\n  finish() {\n    let name, ds;\n\n    // annotate root\n    if (this.root) this.root.root = true;\n\n    // annotate signals\n    for (name in this.signals) {\n      this.signals[name].signal = name;\n    }\n\n    // annotate scales\n    for (name in this.scales) {\n      this.scales[name].scale = name;\n    }\n\n    // annotate data sets\n    function annotate(op, name, type) {\n      let data, list;\n      if (op) {\n        data = op.data || (op.data = {});\n        list = data[name] || (data[name] = []);\n        list.push(type);\n      }\n    }\n    for (name in this.data) {\n      ds = this.data[name];\n      annotate(ds.input,  name, 'input');\n      annotate(ds.output, name, 'output');\n      annotate(ds.values, name, 'values');\n      for (const field in ds.index) {\n        annotate(ds.index[field], name, 'index:' + field);\n      }\n    }\n\n    return this;\n  },\n\n  // ----\n\n  pushState(encode, parent, lookup) {\n    this._encode.push(ref(this.add(Sieve({pulse: encode}))));\n    this._parent.push(parent);\n    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n    this._markpath.push(-1);\n  },\n\n  popState() {\n    this._encode.pop();\n    this._parent.pop();\n    this._lookup.pop();\n    this._markpath.pop();\n  },\n\n  parent() {\n    return peek(this._parent);\n  },\n\n  encode() {\n    return peek(this._encode);\n  },\n\n  lookup() {\n    return peek(this._lookup);\n  },\n\n  markpath() {\n    const p = this._markpath;\n    return ++p[p.length-1];\n  },\n\n  // ----\n\n  fieldRef(field, name) {\n    if (isString(field)) return fieldRef(field, name);\n    if (!field.signal) {\n      error('Unsupported field reference: ' + stringValue(field));\n    }\n\n    const s = field.signal;\n    let f = this.field[s];\n\n    if (!f) {\n      const params = {name: this.signalRef(s)};\n      if (name) params.as = name;\n      this.field[s] = f = ref(this.add(Field(params)));\n    }\n    return f;\n  },\n\n  compareRef(cmp) {\n    let signal = false;\n\n    const check = _ => isSignal(_)\n      ? (signal = true, this.signalRef(_.signal))\n      : isExpr(_) ? (signal = true, this.exprRef(_.expr))\n      : _;\n\n    const fields = array(cmp.field).map(check),\n          orders = array(cmp.order).map(check);\n\n    return signal\n      ? ref(this.add(Compare({fields: fields, orders: orders})))\n      : compareRef(fields, orders);\n  },\n\n  keyRef(fields, flat) {\n    let signal = false;\n\n    const check = _ => isSignal(_)\n      ? (signal = true, ref(sig[_.signal]))\n      : _;\n\n    const sig = this.signals;\n    fields = array(fields).map(check);\n\n    return signal\n      ? ref(this.add(Key({fields: fields, flat: flat})))\n      : keyRef(fields, flat);\n  },\n\n  sortRef(sort) {\n    if (!sort) return sort;\n\n    // including id ensures stable sorting\n    const a = aggrField(sort.op, sort.field),\n         o = sort.order || Ascending;\n\n    return o.signal\n      ? ref(this.add(Compare({\n          fields: a,\n          orders: this.signalRef(o.signal)\n        })))\n      : compareRef(a, o);\n  },\n\n  // ----\n\n  event(source, type) {\n    const key = source + ':' + type;\n    if (!this.events[key]) {\n      const id = this.id();\n      this.streams.push({\n        id: id,\n        source: source,\n        type: type\n      });\n      this.events[key] = id;\n    }\n    return this.events[key];\n  },\n\n  // ----\n\n  hasOwnSignal(name) {\n    return hasOwnProperty(this.signals, name);\n  },\n\n  addSignal(name, value) {\n    if (this.hasOwnSignal(name)) {\n      error('Duplicate signal name: ' + stringValue(name));\n    }\n    const op = value instanceof Entry ? value : this.add(operator(value));\n    return this.signals[name] = op;\n  },\n\n  getSignal(name) {\n    if (!this.signals[name]) {\n      error('Unrecognized signal name: ' + stringValue(name));\n    }\n    return this.signals[name];\n  },\n\n  signalRef(s) {\n    if (this.signals[s]) {\n      return ref(this.signals[s]);\n    } else if (!hasOwnProperty(this.lambdas, s)) {\n      this.lambdas[s] = this.add(operator(null));\n    }\n    return ref(this.lambdas[s]);\n  },\n\n  parseLambdas() {\n    const code = Object.keys(this.lambdas);\n    for (let i=0, n=code.length; i<n; ++i) {\n      const s = code[i],\n            e = parseExpression(s, this),\n            op = this.lambdas[s];\n      op.params = e.$params;\n      op.update = e.$expr;\n    }\n  },\n\n  property(spec) {\n    return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n  },\n\n  objectProperty(spec) {\n    return (!spec || !isObject(spec)) ? spec\n      : this.signalRef(spec.signal || propertyLambda(spec));\n  },\n\n  exprRef(code, name) {\n    const params = {expr: parseExpression(code, this)};\n    if (name) params.expr.$name = name;\n    return ref(this.add(Expression(params)));\n  },\n\n  addBinding(name, bind) {\n    if (!this.bindings) {\n      error('Nested signals do not support binding: ' + stringValue(name));\n    }\n    this.bindings.push(extend({signal: name}, bind));\n  },\n\n  // ----\n\n  addScaleProj(name, transform) {\n    if (hasOwnProperty(this.scales, name)) {\n      error('Duplicate scale or projection name: ' + stringValue(name));\n    }\n    this.scales[name] = this.add(transform);\n  },\n\n  addScale(name, params) {\n    this.addScaleProj(name, Scale(params));\n  },\n\n  addProjection(name, params) {\n    this.addScaleProj(name, Projection(params));\n  },\n\n  getScale(name) {\n    if (!this.scales[name]) {\n      error('Unrecognized scale name: ' + stringValue(name));\n    }\n    return this.scales[name];\n  },\n\n  scaleRef(name) {\n    return ref(this.getScale(name));\n  },\n\n  scaleType(name) {\n    return this.getScale(name).params.type;\n  },\n\n  projectionRef(name) {\n    return this.scaleRef(name);\n  },\n\n  projectionType(name) {\n    return this.scaleType(name);\n  },\n\n  // ----\n\n  addData(name, dataScope) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n    return (this.data[name] = dataScope);\n  },\n\n  getData(name) {\n    if (!this.data[name]) {\n      error('Undefined data set name: ' + stringValue(name));\n    }\n    return this.data[name];\n  },\n\n  addDataPipeline(name, entries) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n    return this.addData(name, DataScope.fromEntries(this, entries));\n  }\n};\n\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\n\nfunction arrayLambda(array) {\n  const n = array.length;\n  let code = '[';\n\n  for (let i = 0; i<n; ++i) {\n    const value = array[i];\n    code += (i > 0 ? ',' : '')\n      + (isObject(value)\n        ? (value.signal || propertyLambda(value))\n        : stringValue(value));\n  }\n  return code + ']';\n}\n\nfunction objectLambda(obj) {\n  let code = '{',\n      i = 0,\n      key, value;\n\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '')\n      + stringValue(key) + ':'\n      + (isObject(value)\n        ? (value.signal || propertyLambda(value))\n        : stringValue(value));\n  }\n  return code + '}';\n}\n","/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\nexport default function() {\n  const defaultFont = 'sans-serif',\n        defaultSymbolSize = 30,\n        defaultStrokeWidth = 2,\n        defaultColor = '#4c78a8',\n        black = '#000',\n        gray = '#888',\n        lightGray = '#ddd';\n\n  return {\n    // default visualization description\n    description: 'Vega visualization',\n\n    // default padding around visualization\n    padding: 0,\n\n    // default for automatic sizing; options: 'none', 'pad', 'fit'\n    // or provide an object (e.g., {'type': 'pad', 'resize': true})\n    autosize: 'pad',\n\n    // default view background color\n    // covers the entire view component\n    background: null,\n\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {allow: ['wheel']}\n    },\n\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: {\n      fill: defaultColor\n    },\n    area: {\n      fill: defaultColor\n    },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: {\n      stroke: defaultColor\n    },\n    rect: {\n      fill: defaultColor\n    },\n    rule: {\n      stroke: black\n    },\n    shape: {\n      stroke: defaultColor\n    },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n    trail: {\n      fill: defaultColor,\n      size: defaultStrokeWidth\n    },\n\n    // style definitions\n    style: {\n      // axis & legend labels\n      'guide-label': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      'guide-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      'group-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // chart subtitle\n      'group-subtitle': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 12\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      }\n    },\n\n    // defaults for title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4,\n      subtitlePadding: 3\n    },\n\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelOffset: 0,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titlePadding: 4\n    },\n\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -0.5\n    },\n\n    // defaults for cartographic projection\n    projection: {\n      type: 'mercator'\n    },\n\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolLimit: 30,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleLimit: 180,\n      titleOrient: 'top',\n      titlePadding: 5,\n      layout: {\n        offset: 18,\n        direction: 'horizontal',\n        left:   { direction: 'vertical' },\n        right:  { direction: 'vertical' }\n      }\n    },\n\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues'\n      },\n      heatmap: {\n        scheme: 'yellowgreenblue'\n      },\n      ramp: {\n        scheme: 'blues'\n      },\n      diverging: {\n        scheme: 'blueorange',\n        extent: [1, 0]\n      },\n      symbol: [\n        'circle',\n        'square',\n        'triangle-up',\n        'cross',\n        'diamond',\n        'triangle-right',\n        'triangle-down',\n        'triangle-left'\n      ]\n    }\n  };\n}\n","import parseView from './parsers/view';\nimport Scope from './Scope';\nimport defaults from './config';\nimport {error, isObject, mergeConfig} from 'vega-util';\n\nexport default function(spec, config, options) {\n  if (!isObject(spec)) {\n    error('Input Vega specification must be an object.');\n  }\n\n  config = mergeConfig(defaults(), config, spec.config);\n  return parseView(spec, new Scope(config, options)).toRuntime();\n}\n"],"names":["spec","isObject","type","number","_","signal","top","bottom","left","right","encoder","isArray","extend","value","addEncode","object","name","set","length","update","addEncoders","enter","extendEncode","encode","extra","skip","hasOwnProperty","has","key","MarkRole","FrameRole","ScopeRole","AxisRole","AxisDomainRole","AxisGridRole","AxisLabelRole","AxisTickRole","AxisTitleRole","LegendRole","LegendEntryRole","LegendLabelRole","LegendSymbolRole","LegendTitleRole","TitleTextRole","TitleSubtitleRole","applyDefault","defaults","scaleRef","scale","isString","stringValue","field","entry","enc","gradient","args","start","stop","count","map","peek","pop","unshift","join","color","c","_color","h","l","s","a","b","r","g","undefined","range","band","property","exponent","mult","offset","round","x","y","z","ref","resolveField","datum","level","group","parent","Math","max","error","splitAccessPath","role","style","scope","params","encoders","$encode","config","props","String","startsWith","mark","array","forEach","applyDefaults","parseBlock","block","marktype","channels","fields","parse","code","rule","test","$expr","$fields","Object","keys","$output","expr","parseExpression","$params","OUTER_INVALID","outerError","prefix","push","signals","prop","op","addSignal","react","bind","addBinding","Entry","id","this","operator","$ref","refs","fieldRef","$field","$name","keyFieldRef","compareRef","orders","$compare","$order","aggrField","Scope","View","isSignal","hasSignal","specValue","defaultValue","deref","v","Timer","parseStream","stream","merge","mergeStream","nestedStream","eventStream","streamParameters","addStream","source","event","throttle","between","filter","param","concat","markname","markrole","item","filterMark","debounce","consume","OP_VALUE_EXPR","ast","target","events","sources","selector","isSubscope","mergeSources","$value","signalRef","force","options","addUpdate","streamSource","getSignal","init","initonly","on","parseUpdate","transform","Aggregate","AxisTicks","Bound","Collect","Compare","DataJoin","Encode","Expression","Facet","Field","Key","LegendEntries","Load","Mark","MultiExtent","MultiValues","Overlap","Params","PreFacet","Projection","Proxy","Relay","Render","Scale","Sieve","SortItems","ViewLayout","Values","FIELD_REF_ID","MULTIDOMAIN_SORT_OPS","min","parseScale","getScale","nice","domain","parseScaleDomain","parseScaleRange","interpolate","parseLiteral","gamma","interpolateGamma","parseScaleInterpolate","interval","step","bins","parseArray","objectProperty","parseScaleBins","dataLookupError","explicitDomain","multipleDomain","singularDomain","domainMin","domainMax","data","getData","isDiscrete","valuesRef","parseSort","sort","isQuantile","domainRef","extentRef","reduce","dom","d","coll","$ingest","input","addDataPipeline","ordinalMultipleDomain","quantileMultipleDomain","numericMultipleDomain","counts","f","countsRef","p","groupby","pulse","ops","as","add","sortRef","multidomain","values","extents","scheme","extent","schemeExtent","schemeCount","rangeStep","parseParameter","Top","Left","Right","Bottom","Center","Index","Label","Perc","Value","GuideLabelStyle","GuideTitleStyle","GroupTitleStyle","GroupSubtitleStyle","Symbols","Gradient","Discrete","Size","LegendScales","Skip","interactive","zero","one","GroupMark","RectMark","RuleMark","TextMark","lookup","dflt","isVertical","direction","symbolDirection","gradientDirection","gradientLength","gradientWidth","gradientThickness","gradientHeight","entryColumns","columns","getEncoding","anchorExpr","e","m","alignExpr","extendOffset","assign","extras","userEncode","vertical","thickness","width","height","opacity","fill","exit","stroke","strokeWidth","guideMark","dataRef","u","uu","vv","adjust","from","baselineExpr","overlap","text","fillOpacity","font","fontSize","fontStyle","fontWeight","limit","labelLimit","gradientLabelLimit","align","baseline","labelOffset","gradientLabelOffset","separation","method","order","entries","symbolOffset","valueRef","xSignal","yEncode","index","ncols","nrows","baseFill","baseStroke","symbolBaseFillColor","symbolBaseStrokeColor","shape","size","strokeDash","strokeDashOffset","symbols","clip","labels","noBound","row","column","guideGroup","facet","marks","isL","isR","isLR","isVG","alignFlip","exprAlign","exprAnchor","exprAngle","exprBaseline","path","sphere","indexOf","zindex","aria","description","def","definition","t","toLowerCase","parseParameters","proxy","metadata","n","i","pdef","lookupRef","parseIndexParameter","parseSubParameter","parseSubParameters","projectionRef","parameterValue","required","isExpr","isField","isCompare","outerExpr","exprRef","outerField","isData","k","getDataRef","output","DataScope","aggr","aggregate","fieldKey","addSortField","cache","ds","optype","sortKey","remove","insert","toggle","modify","trigger","getRole","store","layoutRef","boundRef","layout","nested","parseTransform","keyRef","parseData","clean","joinRef","markdef","context","$context","groups","markpath","markRef","parseEncode","mod","tx","md","generates","changes","nomod","encodeRef","legends","bound","operators","pushState","subscope","fork","addData","subflow","$subflow","toRuntime","parseFacet","parseSubflow","popState","sep","tol","tolerance","boundTolerance","boundScale","boundOrient","orient","parseOverlap","render","sieve","parseTrigger","legend","legendEncode","scales","entryLayout","children","scaleType","scaleCount","isContinuous","isDiscretizing","legendType","title","vgrad","entryRef","minstep","tickMinStep","formatType","formatSpecifier","format","legendGradient","legendGradientLabels","legendGradientDiscrete","center","padding","legendSymbolLayout","legendSymbolGroups","getChannel","getStyle","getFontSize","sizeExpression","_anchor","anchor","angle","lineHeight","legendTitle","parseMark","buildLegendEncode","titlePadding","cornerRadius","fromEntries","prototype","agg","tuplesRef","indataRef","angleExpr","dx","dy","buildTitle","titleEncode","subtitle","buildSubTitle","groupEncode","frame","transforms","upstream","generate","load","collect","$format","url","$request","modifies","derive","splice","analyze","async","isX","getSign","ifLeftTopExpr","ifX","ifXEnc","ifY","ifYEnc","ifTop","ifTopExpr","$orient","ifEnc","ifExpr","ifRightExpr","isSimple","toExpr","patch","base","endsWith","slice","fallback","axisConfig","styleProp","objects","obj","position","pos","vscale","gridScale","sign","offsetValue","strokeCap","strokeOpacity","tickPos","sz","gridStart","gridEnd","x2","y2","flushExpr","threshold","flush","flushOffset","labelAlign","labelBaseline","flushOn","tickSize","ifRight","offsetExpr","titlePos","auto","dim","autoY","autoX","autoLayout","xy","or","axis","axisBand","xyKeys","axisX","axisY","orientKeys","axisTop","axisBottom","axisLeft","axisRight","toUpperCase","axisEncode","tickBand","ticks","grid","ticksRef","tickCount","axisGrid","axisTicks","axisLabels","pos0","pos1","axisDomain","axisTitle","buildAxisEncode","minExtent","maxExtent","translate","preprocessed","parseSignal","projections","proj","projection","addProjection","parseProjection","isValidScaleType","addScale","initScale","parseSignalUpdates","axes","parseAxis","parseLegend","parseTitle","parseLambdas","parseView","root","signalObject","parseAutosize","parsePadding","pre","collectSignals","eventConfig","locale","rootEncode","autosize","parseSpec","bindings","lambdas","streams","updates","_id","_subid","_nextsub","_parent","_encode","_lookup","_markpath","Subscope","create","propertyLambda","arrayLambda","objectLambda","defaultFont","defaultColor","black","gray","lightGray","background","allow","arc","area","image","line","rect","symbol","trail","point","circle","square","cell","subtitlePadding","bandPosition","domainWidth","domainColor","gridWidth","gridColor","labelAngle","labelPadding","tickColor","tickOffset","tickRound","tickWidth","gridAlign","columnPadding","rowPadding","gradientStrokeColor","gradientStrokeWidth","labelOverlap","symbolLimit","symbolType","symbolSize","symbolStrokeWidth","titleLimit","titleOrient","category","ordinal","heatmap","ramp","diverging","parseScope","finish","vref","annotate","list","cmp","check","flat","sig","$key","$flat","o","hasOwnSignal","addScaleProj","projectionType","dataScope","mergeConfig"],"mappings":"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"}