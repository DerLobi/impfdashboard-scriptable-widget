var vega=function(e,r,a,s){"use strict";function n(e,r){var a,s,n,t,o,i,l=[],u=function(e){return e(t)};if(null==r)l.push(e);else for(a={},s=0,n=e.length;s<n;++s)t=e[s],(i=a[o=r.map(u)])||(a[o]=i=[],i.dims=o,l.push(i)),i.push(t);return l}function t(e){a.Transform.call(this,null,e)}t.Definition={type:"Loess",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"bandwidth",type:"number",default:.3},{name:"as",type:"string",array:!0}]},s.inherits(t,a.Transform,{transform(e,t){const o=t.fork(t.NO_SOURCE|t.NO_FIELDS);if(!this.value||t.changed()||e.modified()){const i=n(t.materialize(t.SOURCE).source,e.groupby),l=(e.groupby||[]).map(s.accessorName),u=l.length,m=e.as||[s.accessorName(e.x),s.accessorName(e.y)],d=[];i.forEach(s=>{r.regressionLoess(s,e.x,e.y,e.bandwidth||.3).forEach(e=>{const r={};for(let e=0;e<u;++e)r[l[e]]=s.dims[e];r[m[0]]=e[0],r[m[1]]=e[1],d.push(a.ingest(r))})}),this.value&&(o.rem=this.value),this.value=o.add=o.source=d}return o}});const o={linear:r.regressionLinear,log:r.regressionLog,exp:r.regressionExp,pow:r.regressionPow,quad:r.regressionQuad,poly:r.regressionPoly};function i(e){a.Transform.call(this,null,e)}return i.Definition={type:"Regression",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"method",type:"string",default:"linear",values:Object.keys(o)},{name:"order",type:"number",default:3},{name:"extent",type:"number",array:!0,length:2},{name:"params",type:"boolean",default:!1},{name:"as",type:"string",array:!0}]},s.inherits(i,a.Transform,{transform(e,t){const i=t.fork(t.NO_SOURCE|t.NO_FIELDS);if(!this.value||t.changed()||e.modified()){const l=n(t.materialize(t.SOURCE).source,e.groupby),u=(e.groupby||[]).map(s.accessorName),m=e.method||"linear",d=e.order||3,p=((e,r)=>"poly"===e?r:"quad"===e?2:1)(m,d),c=e.as||[s.accessorName(e.x),s.accessorName(e.y)],f=o[m],g=[];let h=e.extent;s.hasOwnProperty(o,m)||s.error("Invalid regression method: "+m),null!=h&&"log"===m&&h[0]<=0&&(t.dataflow.warn("Ignoring extent with values <= 0 for log regression."),h=null),l.forEach(n=>{if(n.length<=p)return void t.dataflow.warn("Skipping regression with more parameters than data points.");const o=f(n,e.x,e.y,d);if(e.params)return void g.push(a.ingest({keys:n.dims,coef:o.coef,rSquared:o.rSquared}));const i=h||s.extent(n,e.x),l=e=>{const r={};for(let e=0;e<u.length;++e)r[u[e]]=n.dims[e];r[c[0]]=e[0],r[c[1]]=e[1],g.push(a.ingest(r))};"linear"===m?i.forEach(e=>l([e,o.predict(e)])):r.sampleCurve(o.predict,i,25,200).forEach(l)}),this.value&&(i.rem=this.value),this.value=i.add=i.source=g}return i}}),e.loess=t,e.regression=i,e}({},vega,vega,vega);
//# sourceMappingURL=vega-regression.min.js.map
