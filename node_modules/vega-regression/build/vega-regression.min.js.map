{"version":3,"file":"vega-regression.min.js","sources":["../src/partition.js","../src/Loess.js","../src/Regression.js"],"sourcesContent":["export default function(data, groupby) {\n  var groups = [],\n      get = function(f) { return f(t); },\n      map, i, n, t, k, g;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map={}, i=0, n=data.length; i<n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = (g = []);\n        g.dims = k;\n        groups.push(g);\n      }\n      g.push(t);\n    }\n  }\n\n  return groups;\n}\n","import partition from './partition';\nimport {regressionLoess} from 'vega-statistics';\nimport {Transform, ingest} from 'vega-dataflow';\nimport {accessorName, inherits} from 'vega-util';\n\n/**\n * Compute locally-weighted regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n */\nexport default function Loess(params) {\n  Transform.call(this, null, params);\n}\n\nLoess.Definition = {\n  'type': 'Loess',\n  'metadata': {'generates': true},\n  'params': [\n    { 'name': 'x', 'type': 'field', 'required': true },\n    { 'name': 'y', 'type': 'field', 'required': true },\n    { 'name': 'groupby', 'type': 'field', 'array': true },\n    { 'name': 'bandwidth', 'type': 'number', 'default': 0.3 },\n    { 'name': 'as', 'type': 'string', 'array': true }\n  ]\n};\n\ninherits(Loess, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby),\n            names = (_.groupby || []).map(accessorName),\n            m = names.length,\n            as = _.as || [accessorName(_.x), accessorName(_.y)],\n            values = [];\n\n      groups.forEach(g => {\n        regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\n          const t = {};\n          for (let i=0; i<m; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        });\n      });\n\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n});\n","import partition from './partition';\nimport {Transform, ingest} from 'vega-dataflow';\nimport {\n  regressionExp, regressionLinear, regressionLog,\n  regressionPoly, regressionPow, regressionQuad, sampleCurve\n} from 'vega-statistics';\nimport {accessorName, error, extent, hasOwnProperty, inherits} from 'vega-util';\n\nconst Methods = {\n  linear: regressionLinear,\n  log:    regressionLog,\n  exp:    regressionExp,\n  pow:    regressionPow,\n  quad:   regressionQuad,\n  poly:   regressionPoly\n};\n\nconst degreesOfFreedom = (method, order) =>\n  method === 'poly' ? order : method === 'quad' ? 2 : 1;\n\n/**\n * Compute regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {string} [params.method='linear'] - The regression method to apply.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n */\nexport default function Regression(params) {\n  Transform.call(this, null, params);\n}\n\nRegression.Definition = {\n  'type': 'Regression',\n  'metadata': {'generates': true},\n  'params': [\n    { 'name': 'x', 'type': 'field', 'required': true },\n    { 'name': 'y', 'type': 'field', 'required': true },\n    { 'name': 'groupby', 'type': 'field', 'array': true },\n    { 'name': 'method', 'type': 'string', 'default': 'linear', 'values': Object.keys(Methods) },\n    { 'name': 'order', 'type': 'number', 'default': 3 },\n    { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2 },\n    { 'name': 'params', 'type': 'boolean', 'default': false },\n    { 'name': 'as', 'type': 'string', 'array': true }\n  ]\n};\n\ninherits(Regression, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby),\n            names = (_.groupby || []).map(accessorName),\n            method = _.method || 'linear',\n            order = _.order || 3,\n            dof = degreesOfFreedom(method, order),\n            as = _.as || [accessorName(_.x), accessorName(_.y)],\n            fit = Methods[method],\n            values = [];\n\n      let domain = _.extent;\n\n      if (!hasOwnProperty(Methods, method)) {\n        error('Invalid regression method: ' + method);\n      }\n\n      if (domain != null) {\n        if (method === 'log' && domain[0] <= 0) {\n          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n          domain = null;\n        }\n      }\n\n      groups.forEach(g => {\n        const n = g.length;\n        if (n <= dof) {\n          pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n          return;\n        }\n\n        const model = fit(g, _.x, _.y, order);\n\n        if (_.params) {\n          // if parameter vectors requested return those\n          values.push(ingest({\n            keys: g.dims,\n            coef: model.coef,\n            rSquared: model.rSquared\n          }));\n          return;\n        }\n\n        const dom = domain || extent(g, _.x),\n              add = p => {\n                const t = {};\n                for (let i=0; i<names.length; ++i) {\n                  t[names[i]] = g.dims[i];\n                }\n                t[as[0]] = p[0];\n                t[as[1]] = p[1];\n                values.push(ingest(t));\n              };\n\n        if (method === 'linear') {\n          // for linear regression we only need the end points\n          dom.forEach(x => add([x, model.predict(x)]));\n        } else {\n          // otherwise return trend line sample points\n          sampleCurve(model.predict, dom, 25, 200).forEach(add);\n        }\n      });\n\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n});\n"],"names":["data","groupby","map","i","n","t","k","g","groups","get","f","push","length","dims","Loess","params","Transform","call","this","Definition","transform","_","pulse","out","fork","NO_SOURCE","NO_FIELDS","value","changed","modified","partition","materialize","SOURCE","source","names","accessorName","m","as","x","y","values","forEach","regressionLoess","bandwidth","p","ingest","rem","add","Methods","linear","regressionLinear","log","regressionLog","exp","regressionExp","pow","regressionPow","quad","regressionQuad","poly","regressionPoly","Regression","Object","keys","method","order","dof","degreesOfFreedom","fit","domain","extent","hasOwnProperty","error","dataflow","warn","model","coef","rSquared","dom","predict","sampleCurve"],"mappings":"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"}