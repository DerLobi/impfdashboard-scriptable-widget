{"version":3,"file":"vega-runtime.min.js","sources":["../src/util.js","../src/expression.js","../src/parameters.js","../src/state.js","../src/context.js","../src/dataflow.js","../src/operator.js","../src/stream.js","../src/update.js"],"sourcesContent":["import {toSet} from 'vega-util';\n\nconst Skip = toSet(['rule']),\n      Swap = toSet(['group', 'image', 'rect']);\n\nexport function adjustSpatial(encode, marktype) {\n  let code = '';\n\n  if (Skip[marktype]) return code;\n\n  if (encode.x2) {\n    if (encode.x) {\n      if (Swap[marktype]) {\n        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';\n      }\n      code += 'o.width=o.x2-o.x;';\n    } else {\n      code += 'o.x=o.x2-(o.width||0);';\n    }\n  }\n\n  if (encode.xc) {\n    code += 'o.x=o.xc-(o.width||0)/2;';\n  }\n\n  if (encode.y2) {\n    if (encode.y) {\n      if (Swap[marktype]) {\n        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';\n      }\n      code += 'o.height=o.y2-o.y;';\n    } else {\n      code += 'o.y=o.y2-(o.height||0);';\n    }\n  }\n\n  if (encode.yc) {\n    code += 'o.y=o.yc-(o.height||0)/2;';\n  }\n\n  return code;\n}\n\nexport function canonicalType(type) {\n  return (type + '').toLowerCase();\n}\n\nexport function isOperator(type) {\n   return canonicalType(type) === 'operator';\n}\n\nexport function isCollect(type) {\n  return canonicalType(type) === 'collect';\n}\n","import {adjustSpatial} from './util';\nimport {stringValue} from 'vega-util';\n\nfunction expression(ctx, args, code) {\n  // wrap code in return statement if expression does not terminate\n  if (code[code.length-1] !== ';') {\n    code = 'return(' + code + ');';\n  }\n  const fn = Function(...args.concat(code));\n  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;\n}\n\n// generate code for comparing a single field\nfunction _compare(u, v, lt, gt) {\n  return `((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt}\n  : (u > v || v == null) && u != null ? ${gt}\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt}\n  : v !== v && u === u ? ${gt} : `;\n}\n\nexport default {\n  /**\n   * Parse an expression used to update an operator value.\n   */\n  operator: (ctx, expr) => expression(ctx, ['_'], expr.code),\n\n  /**\n   * Parse an expression provided as an operator parameter value.\n   */\n  parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),\n\n  /**\n   * Parse an expression applied to an event stream.\n   */\n  event: (ctx, expr) => expression(ctx, ['event'], expr.code),\n\n  /**\n   * Parse an expression used to handle an event-driven operator update.\n   */\n  handler: (ctx, expr) => {\n    const code = `var datum=event.item&&event.item.datum;return ${expr.code};`;\n    return expression(ctx, ['_', 'event'], code);\n  },\n\n  /**\n   * Parse an expression that performs visual encoding.\n   */\n  encode: (ctx, encode) => {\n    const {marktype, channels} = encode;\n\n    let code = 'var o=item,datum=o.datum,m=0,$;';\n    for (const name in channels) {\n      const o ='o[' + stringValue(name) + ']';\n      code += `$=${channels[name].code};if(${o}!==$)${o}=$,m=1;`;\n    }\n    code += adjustSpatial(channels, marktype);\n    code += 'return m;';\n\n    return expression(ctx, ['item', '_'], code);\n  },\n\n  /**\n   * Optimized code generators for access and comparison.\n   */\n  codegen: {\n    get(path) {\n      const ref = `[${path.map(stringValue).join('][')}]`;\n      const get = Function('_', `return _${ref};`);\n      get.path = ref;\n      return get;\n    },\n    comparator(fields, orders) {\n      let t;\n      const map = (f, i) => {\n        const o = orders[i];\n        let u, v;\n        if (f.path) {\n          u = `a${f.path}`;\n          v = `b${f.path}`;\n        } else {\n          (t = t || {})['f'+i] = f;\n          u = `this.f${i}(a)`;\n          v = `this.f${i}(b)`;\n        }\n        return _compare(u, v, -o, o);\n      };\n\n      const fn = Function('a', 'b', 'var u, v; return '\n        + fields.map(map).join('') + '0;');\n      return t ? fn.bind(t) : fn;\n    }\n  }\n};\n","import {tupleid} from 'vega-dataflow';\nimport {\n  accessor, array, compare, error, field,\n  hasOwnProperty, isArray, isObject, key\n} from 'vega-util';\n\n/**\n * Parse a set of operator parameters.\n */\nexport default function parseParameters(spec, params) {\n  params = params || {};\n  const ctx = this;\n\n  for (const key in spec) {\n    const value = spec[key];\n    params[key] = isArray(value)\n      ? value.map(v => parseParameter(v, ctx, params))\n      : parseParameter(value, ctx, params);\n  }\n\n  return params;\n}\n\n/**\n * Parse a single parameter.\n */\nfunction parseParameter(spec, ctx, params) {\n  if (!spec || !isObject(spec)) return spec;\n\n  for (let i=0, n=PARSERS.length, p; i<n; ++i) {\n    p = PARSERS[i];\n    if (hasOwnProperty(spec, p.key)) {\n      return p.parse(spec, ctx, params);\n    }\n  }\n\n  return spec;\n}\n\n/** Reference parsers. */\nvar PARSERS = [\n  {key: '$ref',      parse: getOperator},\n  {key: '$key',      parse: getKey},\n  {key: '$expr',     parse: getExpression},\n  {key: '$field',    parse: getField},\n  {key: '$encode',   parse: getEncode},\n  {key: '$compare',  parse: getCompare},\n  {key: '$context',  parse: getContext},\n  {key: '$subflow',  parse: getSubflow},\n  {key: '$tupleid',  parse: getTupleId}\n];\n\n/**\n * Resolve an operator reference.\n */\nfunction getOperator(_, ctx) {\n  return ctx.get(_.$ref) || error('Operator not defined: ' + _.$ref);\n}\n\n/**\n * Resolve an expression reference.\n */\nfunction getExpression(_, ctx, params) {\n  if (_.$params) { // parse expression parameters\n    ctx.parseParameters(_.$params, params);\n  }\n  const k = 'e:' + _.$expr.code + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = accessor(\n    ctx.parameterExpression(_.$expr),\n    _.$fields,\n    _.$name\n  ));\n}\n\n/**\n * Resolve a key accessor reference.\n */\nfunction getKey(_, ctx) {\n  const k = 'k:' + _.$key + '_' + (!!_.$flat);\n  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat, ctx.expr.codegen));\n}\n\n/**\n * Resolve a field accessor reference.\n */\nfunction getField(_, ctx) {\n  if (!_.$field) return null;\n  const k = 'f:' + _.$field + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name, ctx.expr.codegen));\n}\n\n/**\n * Resolve a comparator function reference.\n */\nfunction getCompare(_, ctx) {\n  // As of Vega 5.5.3, $tupleid sort is no longer used.\n  // Keep here for now for backwards compatibility.\n  const k = 'c:' + _.$compare + '_' + _.$order,\n        c = array(_.$compare).map(_ => (_ && _.$tupleid) ? tupleid : _);\n  return ctx.fn[k] || (ctx.fn[k] = compare(c, _.$order, ctx.expr.codegen));\n}\n\n/**\n * Resolve an encode operator reference.\n */\nfunction getEncode(_, ctx) {\n  const spec = _.$encode,\n        encode = {};\n\n  for (const name in spec) {\n    const enc = spec[name];\n    encode[name] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);\n    encode[name].output = enc.$output;\n  }\n  return encode;\n}\n\n/**\n * Resolve a context reference.\n */\nfunction getContext(_, ctx) {\n  return ctx;\n}\n\n/**\n * Resolve a recursive subflow specification.\n */\nfunction getSubflow(_, ctx) {\n  const spec = _.$subflow;\n  return function(dataflow, key, parent) {\n    const subctx = ctx.fork().parse(spec),\n          op = subctx.get(spec.operators[0].id),\n          p = subctx.signals.parent;\n    if (p) p.set(parent);\n    op.detachSubflow = () => ctx.detach(subctx);\n    return op;\n  };\n}\n\n/**\n * Resolve a tuple id reference.\n */\nfunction getTupleId() {\n  return tupleid;\n}\n","import {truthy} from 'vega-util';\n\nconst SKIP = {skip: true};\n\nexport function getState(options) {\n  var ctx = this,\n      state = {};\n\n  if (options.signals) {\n    var signals = (state.signals = {});\n    Object.keys(ctx.signals).forEach(key => {\n      const op = ctx.signals[key];\n      if (options.signals(key, op)) {\n        signals[key] = op.value;\n      }\n    });\n  }\n\n  if (options.data) {\n    var data = (state.data = {});\n    Object.keys(ctx.data).forEach(key => {\n      const dataset = ctx.data[key];\n      if (options.data(key, dataset)) {\n        data[key] = dataset.input.value;\n      }\n    });\n  }\n\n  if (ctx.subcontext && options.recurse !== false) {\n    state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));\n  }\n\n  return state;\n}\n\nexport function setState(state) {\n  var ctx = this,\n      df = ctx.dataflow,\n      data = state.data,\n      signals = state.signals;\n\n  Object.keys(signals || {}).forEach(key => {\n    df.update(ctx.signals[key], signals[key], SKIP);\n  });\n\n  Object.keys(data || {}).forEach(key => {\n    df.pulse(\n      ctx.data[key].input,\n      df.changeset().remove(truthy).insert(data[key])\n    );\n  });\n\n  (state.subcontext  || []).forEach((substate, i) => {\n    const subctx = ctx.subcontext[i];\n    if (subctx) subctx.setState(substate);\n  });\n}\n","import parse from './dataflow';\nimport expressionCodegen from './expression';\nimport {\n  parseOperator,\n  parseOperatorParameters\n} from './operator';\nimport parseParameters from './parameters';\nimport parseStream from './stream';\nimport parseUpdate from './update';\n\nimport {getState, setState} from './state';\nimport {canonicalType, isCollect} from './util';\n\n/**\n * Context objects store the current parse state.\n * Enables lookup of parsed operators, event streams, accessors, etc.\n * Provides a 'fork' method for creating child contexts for subflows.\n */\nexport default function(df, transforms, functions, expr) {\n  return new Context(df, transforms, functions, expr);\n}\n\nfunction Context(df, transforms, functions, expr) {\n  this.dataflow = df;\n  this.transforms = transforms;\n  this.events = df.events.bind(df);\n  this.expr = expr || expressionCodegen,\n  this.signals = {};\n  this.scales = {};\n  this.nodes = {};\n  this.data = {};\n  this.fn = {};\n  if (functions) {\n    this.functions = Object.create(functions);\n    this.functions.context = this;\n  }\n}\n\nfunction Subcontext(ctx) {\n  this.dataflow = ctx.dataflow;\n  this.transforms = ctx.transforms;\n  this.events = ctx.events;\n  this.expr = ctx.expr;\n  this.signals = Object.create(ctx.signals);\n  this.scales = Object.create(ctx.scales);\n  this.nodes = Object.create(ctx.nodes);\n  this.data = Object.create(ctx.data);\n  this.fn = Object.create(ctx.fn);\n  if (ctx.functions) {\n    this.functions = Object.create(ctx.functions);\n    this.functions.context = this;\n  }\n}\n\nContext.prototype = Subcontext.prototype = {\n  fork() {\n    const ctx = new Subcontext(this);\n    (this.subcontext || (this.subcontext = [])).push(ctx);\n    return ctx;\n  },\n  detach(ctx) {\n    this.subcontext = this.subcontext.filter(c => c !== ctx);\n\n    // disconnect all nodes in the subcontext\n    // wipe out targets first for better efficiency\n    const keys = Object.keys(ctx.nodes);\n    for (const key of keys) ctx.nodes[key]._targets = null;\n    for (const key of keys) ctx.nodes[key].detach();\n    ctx.nodes = null;\n  },\n  get(id) {\n    return this.nodes[id];\n  },\n  set(id, node) {\n    return this.nodes[id] = node;\n  },\n  add(spec, op) {\n    const ctx = this,\n          df = ctx.dataflow,\n          data = spec.value;\n\n    ctx.set(spec.id, op);\n\n    if (isCollect(spec.type) && data) {\n      if (data.$ingest) {\n        df.ingest(op, data.$ingest, data.$format);\n      } else if (data.$request) {\n        df.preload(op, data.$request, data.$format);\n      } else {\n        df.pulse(op, df.changeset().insert(data));\n      }\n    }\n\n    if (spec.root) {\n      ctx.root = op;\n    }\n\n    if (spec.parent) {\n      let p = ctx.get(spec.parent.$ref);\n      if (p) {\n        df.connect(p, [op]);\n        op.targets().add(p);\n      } else {\n        (ctx.unresolved = ctx.unresolved || []).push(() => {\n          p = ctx.get(spec.parent.$ref);\n          df.connect(p, [op]);\n          op.targets().add(p);\n        });\n      }\n    }\n\n    if (spec.signal) {\n      ctx.signals[spec.signal] = op;\n    }\n\n    if (spec.scale) {\n      ctx.scales[spec.scale] = op;\n    }\n\n    if (spec.data) {\n      for (const name in spec.data) {\n        const data = ctx.data[name] || (ctx.data[name] = {});\n        spec.data[name].forEach(role => data[role] = op);\n      }\n    }\n  },\n  resolve() {\n    (this.unresolved || []).forEach(fn => fn());\n    delete this.unresolved;\n    return this;\n  },\n  operator(spec, update) {\n    this.add(spec, this.dataflow.add(spec.value, update));\n  },\n  transform(spec, type) {\n    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n  },\n  stream(spec, stream) {\n    this.set(spec.id, stream);\n  },\n  update(spec, stream, target, update, params) {\n    this.dataflow.on(stream, target, update, params, spec.options);\n  },\n\n  // expression parsing\n  operatorExpression(expr) {\n    return this.expr.operator(this, expr);\n  },\n  parameterExpression(expr) {\n    return this.expr.parameter(this, expr);\n  },\n  eventExpression(expr) {\n    return this.expr.event(this, expr);\n  },\n  handlerExpression(expr) {\n    return this.expr.handler(this, expr);\n  },\n  encodeExpression(encode) {\n    return this.expr.encode(this, encode);\n  },\n\n  // parse methods\n  parse,\n  parseOperator,\n  parseOperatorParameters,\n  parseParameters,\n  parseStream,\n  parseUpdate,\n\n  // state methods\n  getState,\n  setState\n};\n","/**\n * Parse a serialized dataflow specification.\n */\nexport default function(spec) {\n  const ctx = this,\n        operators = spec.operators || [];\n\n  // parse background\n  if (spec.background) {\n    ctx.background = spec.background;\n  }\n\n  // parse event configuration\n  if (spec.eventConfig) {\n    ctx.eventConfig = spec.eventConfig;\n  }\n\n  // parse locale configuration\n  if (spec.locale) {\n    ctx.locale = spec.locale;\n  }\n\n  // parse operators\n  operators.forEach(entry => ctx.parseOperator(entry));\n\n  // parse operator parameters\n  operators.forEach(entry => ctx.parseOperatorParameters(entry));\n\n  // parse streams\n  (spec.streams || []).forEach(entry => ctx.parseStream(entry));\n\n  // parse updates\n  (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));\n\n  return ctx.resolve();\n}\n","import {isOperator} from './util';\nimport {error} from 'vega-util';\n\n/**\n * Parse a dataflow operator.\n */\nexport function parseOperator(spec) {\n  const ctx = this;\n  if (isOperator(spec.type) || !spec.type) {\n    ctx.operator(\n      spec,\n      spec.update ? ctx.operatorExpression(spec.update) : null\n    );\n  } else {\n    ctx.transform(spec, spec.type);\n  }\n}\n\n/**\n * Parse and assign operator parameters.\n */\nexport function parseOperatorParameters(spec) {\n  const ctx = this;\n  if (spec.params) {\n    const op = ctx.get(spec.id);\n    if (!op) error('Invalid operator id: ' + spec.id);\n    ctx.dataflow.connect(op, op.parameters(\n      ctx.parseParameters(spec.params),\n      spec.react,\n      spec.initonly\n    ));\n  }\n}\n","import {error} from 'vega-util';\n\n/**\n * Parse an event stream specification.\n */\nexport default function(spec) {\n  var ctx = this,\n      filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,\n      stream = spec.stream != null ? ctx.get(spec.stream) : undefined,\n      args;\n\n  if (spec.source) {\n    stream = ctx.events(spec.source, spec.type, filter);\n  }\n  else if (spec.merge) {\n    args = spec.merge.map(_ => ctx.get(_));\n    stream = args[0].merge.apply(args[0], args.slice(1));\n  }\n\n  if (spec.between) {\n    args = spec.between.map(_ => ctx.get(_));\n    stream = stream.between(args[0], args[1]);\n  }\n\n  if (spec.filter) {\n    stream = stream.filter(filter);\n  }\n\n  if (spec.throttle != null) {\n    stream = stream.throttle(+spec.throttle);\n  }\n\n  if (spec.debounce != null) {\n    stream = stream.debounce(+spec.debounce);\n  }\n\n  if (stream == null) {\n    error('Invalid stream definition: ' + JSON.stringify(spec));\n  }\n\n  if (spec.consume) stream.consume(true);\n\n  ctx.stream(spec, stream);\n}\n","import {error, isObject} from 'vega-util';\n\n/**\n * Parse an event-driven operator update.\n */\nexport default function(spec) {\n  var ctx = this,\n      srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid,\n      source = ctx.get(srcid),\n      target = null,\n      update = spec.update,\n      params = undefined;\n\n  if (!source) error('Source not defined: ' + spec.source);\n\n  target = spec.target && spec.target.$expr\n    ? ctx.eventExpression(spec.target.$expr)\n    : ctx.get(spec.target);\n\n  if (update && update.$expr) {\n    if (update.$params) {\n      params = ctx.parseParameters(update.$params);\n    }\n    update = ctx.handlerExpression(update.$expr);\n  }\n\n  ctx.update(spec, source, target, update, params);\n}\n"],"names":["Skip","toSet","Swap","canonicalType","type","toLowerCase","expression","ctx","args","code","length","fn","Function","concat","functions","bind","operator","expr","parameter","event","handler","encode","marktype","channels","name","o","stringValue","x2","x","xc","y2","y","yc","adjustSpatial","codegen","get","path","ref","map","join","comparator","fields","orders","t","f","i","u","v","lt","gt","_compare","parseParameter","spec","params","isObject","p","n","PARSERS","hasOwnProperty","key","parse","_","$ref","error","k","$key","$flat","$params","parseParameters","$expr","$name","accessor","parameterExpression","$fields","$field","field","$encode","enc","encodeExpression","output","$output","$compare","$order","c","array","$tupleid","tupleid","compare","$subflow","dataflow","parent","subctx","fork","op","operators","id","signals","set","detachSubflow","detach","SKIP","skip","Context","df","transforms","events","expressionCodegen","this","scales","nodes","data","Object","create","context","Subcontext","prototype","subcontext","push","filter","keys","_targets","node","add","value","$ingest","ingest","$format","$request","preload","pulse","changeset","insert","root","connect","targets","unresolved","signal","scale","forEach","role","resolve","update","transform","stream","target","on","options","operatorExpression","eventExpression","handlerExpression","background","eventConfig","locale","entry","parseOperator","parseOperatorParameters","streams","parseStream","updates","parseUpdate","parameters","react","initonly","isArray","undefined","source","merge","apply","slice","between","throttle","debounce","JSON","stringify","consume","srcid","getState","state","dataset","input","recurse","setState","remove","truthy","substate"],"mappings":"sCAEA,MAAMA,EAAOC,QAAM,CAAC,SACdC,EAAOD,QAAM,CAAC,QAAS,QAAS,SAwC/B,SAASE,EAAcC,UACpBA,EAAO,IAAIC,cCzCrB,SAASC,EAAWC,EAAKC,EAAMC,GAED,MAAxBA,EAAKA,EAAKC,OAAO,KACnBD,EAAO,UAAYA,EAAO,YAEtBE,EAAKC,YAAYJ,EAAKK,OAAOJ,WAC5BF,GAAOA,EAAIO,UAAYH,EAAGI,KAAKR,EAAIO,WAAaH,QAW1C,CAIbK,SAAU,CAACT,EAAKU,IAASX,EAAWC,EAAK,CAAC,KAAMU,EAAKR,MAKrDS,UAAW,CAACX,EAAKU,IAASX,EAAWC,EAAK,CAAC,QAAS,KAAMU,EAAKR,MAK/DU,MAAO,CAACZ,EAAKU,IAASX,EAAWC,EAAK,CAAC,SAAUU,EAAKR,MAKtDW,QAAS,CAACb,EAAKU,IAENX,EAAWC,EAAK,CAAC,IAAK,iEADiCU,EAAKR,WAOrEY,OAAQ,CAACd,EAAKc,WACNC,SAACA,EAADC,SAAWA,GAAYF,MAEzBZ,EAAO,sCACN,MAAMe,KAAQD,EAAU,OACrBE,EAAG,KAAOC,cAAYF,GAAQ,IACpCf,eAAac,EAASC,GAAMf,oBAAWgB,kBAASA,oBAElDhB,GDlDG,SAAuBY,EAAQC,OAChCb,EAAO,UAEPT,EAAKsB,KAELD,EAAOM,KACLN,EAAOO,GACL1B,EAAKoB,KACPb,GAAQ,sCAEVA,GAAQ,qBAERA,GAAQ,0BAIRY,EAAOQ,KACTpB,GAAQ,4BAGNY,EAAOS,KACLT,EAAOU,GACL7B,EAAKoB,KACPb,GAAQ,sCAEVA,GAAQ,sBAERA,GAAQ,2BAIRY,EAAOW,KACTvB,GAAQ,8BA7BiBA,EC+CjBwB,CAAcV,EAAUD,GAChCb,GAAQ,YAEDH,EAAWC,EAAK,CAAC,OAAQ,KAAME,IAMxCyB,QAAS,CACPC,IAAIC,SACIC,aAAUD,EAAKE,IAAIZ,eAAaa,KAAK,WACrCJ,EAAMvB,SAAS,sBAAgByB,eACrCF,EAAIC,KAAOC,EACJF,GAETK,WAAWC,EAAQC,OACbC,QAeEhC,EAAKC,SAAS,IAAK,IAAK,oBAC1B6B,EAAOH,IAfC,CAACM,EAAGC,WACRpB,EAAIiB,EAAOG,OACbC,EAAGC,SACHH,EAAER,MACJU,aAAQF,EAAER,MACVW,aAAQH,EAAER,SAETO,EAAIA,GAAK,IAAI,IAAIE,GAAKD,EACvBE,kBAAaD,SACbE,kBAAaF,UArEvB,SAAkBC,EAAGC,EAAGC,EAAIC,yBACVH,sBAAaC,4CAAmCC,uDACxBC,2GACoDD,wCACnEC,SAmEZC,CAASJ,EAAGC,GAAItB,EAAGA,KAIRc,KAAK,IAAM,aACxBI,EAAIhC,EAAGI,KAAK4B,GAAKhC,KC/D9B,SAASwC,EAAeC,EAAM7C,EAAK8C,OAC5BD,IAASE,WAASF,GAAO,OAAOA,MAEhC,IAA2BG,EAAvBV,EAAE,EAAGW,EAAEC,EAAQ/C,OAAWmC,EAAEW,IAAKX,KACxCU,EAAIE,EAAQZ,GACRa,iBAAeN,EAAMG,EAAEI,YAClBJ,EAAEK,MAAMR,EAAM7C,EAAK8C,UAIvBD,EAIT,IAAIK,EAAU,CACZ,CAACE,IAAK,OAAaC,MAcrB,SAAqBC,EAAGtD,UACfA,EAAI4B,IAAI0B,EAAEC,OAASC,QAAM,yBAA2BF,EAAEC,QAd7D,CAACH,IAAK,OAAaC,MAmCrB,SAAgBC,EAAGtD,SACXyD,EAAI,KAAOH,EAAEI,KAAO,MAASJ,EAAEK,aAC9B3D,EAAII,GAAGqD,KAAOzD,EAAII,GAAGqD,GAAKL,MAAIE,EAAEI,KAAMJ,EAAEK,MAAO3D,EAAIU,KAAKiB,YApC/D,CAACyB,IAAK,QAAaC,MAmBrB,SAAuBC,EAAGtD,EAAK8C,GACzBQ,EAAEM,SACJ5D,EAAI6D,gBAAgBP,EAAEM,QAASd,SAE3BW,EAAI,KAAOH,EAAEQ,MAAM5D,KAAO,IAAMoD,EAAES,aACjC/D,EAAII,GAAGqD,KAAOzD,EAAII,GAAGqD,GAAKO,WAC/BhE,EAAIiE,oBAAoBX,EAAEQ,OAC1BR,EAAEY,QACFZ,EAAES,UA1BJ,CAACX,IAAK,SAAaC,MAyCrB,SAAkBC,EAAGtD,OACdsD,EAAEa,OAAQ,OAAO,WAChBV,EAAI,KAAOH,EAAEa,OAAS,IAAMb,EAAES,aAC7B/D,EAAII,GAAGqD,KAAOzD,EAAII,GAAGqD,GAAKW,QAAMd,EAAEa,OAAQb,EAAES,MAAO/D,EAAIU,KAAKiB,YA3CnE,CAACyB,IAAK,UAAaC,MA4DrB,SAAmBC,EAAGtD,SACd6C,EAAOS,EAAEe,QACTvD,EAAS,OAEV,MAAMG,KAAQ4B,EAAM,OACjByB,EAAMzB,EAAK5B,GACjBH,EAAOG,GAAQ+C,WAAShE,EAAIuE,iBAAiBD,EAAIR,OAAQQ,EAAIJ,SAC7DpD,EAAOG,GAAMuD,OAASF,EAAIG,eAErB3D,IApEP,CAACsC,IAAK,WAAaC,MAgDrB,SAAoBC,EAAGtD,SAGfyD,EAAI,KAAOH,EAAEoB,SAAW,IAAMpB,EAAEqB,OAChCC,EAAIC,QAAMvB,EAAEoB,UAAU3C,IAAIuB,GAAMA,GAAKA,EAAEwB,SAAYC,UAAUzB,UAC5DtD,EAAII,GAAGqD,KAAOzD,EAAII,GAAGqD,GAAKuB,UAAQJ,EAAGtB,EAAEqB,OAAQ3E,EAAIU,KAAKiB,YApD/D,CAACyB,IAAK,WAAaC,MAyErB,SAAoBC,EAAGtD,UACdA,IAzEP,CAACoD,IAAK,WAAaC,MA+ErB,SAAoBC,EAAGtD,SACf6C,EAAOS,EAAE2B,gBACR,SAASC,EAAU9B,EAAK+B,SACvBC,EAASpF,EAAIqF,OAAOhC,MAAMR,GAC1ByC,EAAKF,EAAOxD,IAAIiB,EAAK0C,UAAU,GAAGC,IAClCxC,EAAIoC,EAAOK,QAAQN,cACrBnC,GAAGA,EAAE0C,IAAIP,GACbG,EAAGK,cAAgB,IAAM3F,EAAI4F,OAAOR,GAC7BE,KAtFT,CAAClC,IAAK,WAAaC,MA6FrB,kBACS0B,aC7IT,MAAMc,EAAO,CAACC,MAAM,GCoBpB,SAASC,EAAQC,EAAIC,EAAY1F,EAAWG,QACrCwE,SAAWc,OACXC,WAAaA,OACbC,OAASF,EAAGE,OAAO1F,KAAKwF,QACxBtF,KAAOA,GAAQyF,EACpBC,KAAKX,QAAU,QACVY,OAAS,QACTC,MAAQ,QACRC,KAAO,QACPnG,GAAK,GACNG,SACGA,UAAYiG,OAAOC,OAAOlG,QAC1BA,UAAUmG,QAAUN,MAI7B,SAASO,EAAW3G,QACbkF,SAAWlF,EAAIkF,cACfe,WAAajG,EAAIiG,gBACjBC,OAASlG,EAAIkG,YACbxF,KAAOV,EAAIU,UACX+E,QAAUe,OAAOC,OAAOzG,EAAIyF,cAC5BY,OAASG,OAAOC,OAAOzG,EAAIqG,aAC3BC,MAAQE,OAAOC,OAAOzG,EAAIsG,YAC1BC,KAAOC,OAAOC,OAAOzG,EAAIuG,WACzBnG,GAAKoG,OAAOC,OAAOzG,EAAII,IACxBJ,EAAIO,iBACDA,UAAYiG,OAAOC,OAAOzG,EAAIO,gBAC9BA,UAAUmG,QAAUN,aAI7BL,EAAQa,UAAYD,EAAWC,UAAY,CACzCvB,aACQrF,EAAM,IAAI2G,EAAWP,aAC1BA,KAAKS,aAAeT,KAAKS,WAAa,KAAKC,KAAK9G,GAC1CA,GAET4F,OAAO5F,QACA6G,WAAaT,KAAKS,WAAWE,OAAOnC,GAAKA,IAAM5E,SAI9CgH,EAAOR,OAAOQ,KAAKhH,EAAIsG,WACxB,MAAMlD,KAAO4D,EAAMhH,EAAIsG,MAAMlD,GAAK6D,SAAW,SAC7C,MAAM7D,KAAO4D,EAAMhH,EAAIsG,MAAMlD,GAAKwC,SACvC5F,EAAIsG,MAAQ,MAEd1E,IAAI4D,UACKY,KAAKE,MAAMd,IAEpBE,IAAIF,EAAI0B,UACCd,KAAKE,MAAMd,GAAM0B,GAE1BC,IAAItE,EAAMyC,SACFtF,EAAMoG,KACNJ,EAAKhG,EAAIkF,SACTqB,EAAO1D,EAAKuE,SAElBpH,EAAI0F,IAAI7C,EAAK2C,GAAIF,GJ7BY,YAAxB1F,EI+BSiD,EAAKhD,OAAS0G,IACtBA,EAAKc,QACPrB,EAAGsB,OAAOhC,EAAIiB,EAAKc,QAASd,EAAKgB,SACxBhB,EAAKiB,SACdxB,EAAGyB,QAAQnC,EAAIiB,EAAKiB,SAAUjB,EAAKgB,SAEnCvB,EAAG0B,MAAMpC,EAAIU,EAAG2B,YAAYC,OAAOrB,KAInC1D,EAAKgF,OACP7H,EAAI6H,KAAOvC,GAGTzC,EAAKsC,OAAQ,KACXnC,EAAIhD,EAAI4B,IAAIiB,EAAKsC,OAAO5B,MACxBP,GACFgD,EAAG8B,QAAQ9E,EAAG,CAACsC,IACfA,EAAGyC,UAAUZ,IAAInE,KAEhBhD,EAAIgI,WAAahI,EAAIgI,YAAc,IAAIlB,KAAK,KAC3C9D,EAAIhD,EAAI4B,IAAIiB,EAAKsC,OAAO5B,MACxByC,EAAG8B,QAAQ9E,EAAG,CAACsC,IACfA,EAAGyC,UAAUZ,IAAInE,QAKnBH,EAAKoF,SACPjI,EAAIyF,QAAQ5C,EAAKoF,QAAU3C,GAGzBzC,EAAKqF,QACPlI,EAAIqG,OAAOxD,EAAKqF,OAAS5C,GAGvBzC,EAAK0D,SACF,MAAMtF,KAAQ4B,EAAK0D,KAAM,OACtBA,EAAOvG,EAAIuG,KAAKtF,KAAUjB,EAAIuG,KAAKtF,GAAQ,IACjD4B,EAAK0D,KAAKtF,GAAMkH,QAAQC,GAAQ7B,EAAK6B,GAAQ9C,KAInD+C,iBACGjC,KAAK4B,YAAc,IAAIG,QAAQ/H,GAAMA,YAC/BgG,KAAK4B,WACL5B,MAET3F,SAASoC,EAAMyF,QACRnB,IAAItE,EAAMuD,KAAKlB,SAASiC,IAAItE,EAAKuE,MAAOkB,KAE/CC,UAAU1F,EAAMhD,QACTsH,IAAItE,EAAMuD,KAAKlB,SAASiC,IAAIf,KAAKH,WAAWrG,EAAcC,OAEjE2I,OAAO3F,EAAM2F,QACN9C,IAAI7C,EAAK2C,GAAIgD,IAEpBF,OAAOzF,EAAM2F,EAAQC,EAAQH,EAAQxF,QAC9BoC,SAASwD,GAAGF,EAAQC,EAAQH,EAAQxF,EAAQD,EAAK8F,UAIxDC,mBAAmBlI,UACV0F,KAAK1F,KAAKD,SAAS2F,KAAM1F,IAElCuD,oBAAoBvD,UACX0F,KAAK1F,KAAKC,UAAUyF,KAAM1F,IAEnCmI,gBAAgBnI,UACP0F,KAAK1F,KAAKE,MAAMwF,KAAM1F,IAE/BoI,kBAAkBpI,UACT0F,KAAK1F,KAAKG,QAAQuF,KAAM1F,IAEjC6D,iBAAiBzD,UACRsF,KAAK1F,KAAKI,OAAOsF,KAAMtF,IAIhCuC,MC/Ja,SAASR,SAChB7C,EAAMoG,KACNb,EAAY1C,EAAK0C,WAAa,UAGhC1C,EAAKkG,aACP/I,EAAI+I,WAAalG,EAAKkG,YAIpBlG,EAAKmG,cACPhJ,EAAIgJ,YAAcnG,EAAKmG,aAIrBnG,EAAKoG,SACPjJ,EAAIiJ,OAASpG,EAAKoG,QAIpB1D,EAAU4C,QAAQe,GAASlJ,EAAImJ,cAAcD,IAG7C3D,EAAU4C,QAAQe,GAASlJ,EAAIoJ,wBAAwBF,KAGtDrG,EAAKwG,SAAW,IAAIlB,QAAQe,GAASlJ,EAAIsJ,YAAYJ,KAGrDrG,EAAK0G,SAAW,IAAIpB,QAAQe,GAASlJ,EAAIwJ,YAAYN,IAE/ClJ,EAAIqI,WDiIXc,cE7JK,SAAuBtG,SACtB7C,EAAMoG,KNyCoB,aAAxBxG,EMxCOiD,EAAKhD,OAAUgD,EAAKhD,KAMjCG,EAAIuI,UAAU1F,EAAMA,EAAKhD,MALzBG,EAAIS,SACFoC,EACAA,EAAKyF,OAAStI,EAAI4I,mBAAmB/F,EAAKyF,QAAU,OFyJxDc,wBE/IK,SAAiCvG,SAChC7C,EAAMoG,QACRvD,EAAKC,OAAQ,OACTwC,EAAKtF,EAAI4B,IAAIiB,EAAK2C,IACnBF,GAAI9B,QAAM,wBAA0BX,EAAK2C,IAC9CxF,EAAIkF,SAAS4C,QAAQxC,EAAIA,EAAGmE,WAC1BzJ,EAAI6D,gBAAgBhB,EAAKC,QACzBD,EAAK6G,MACL7G,EAAK8G,aFwIT9F,gBF5Ja,SAAyBhB,EAAMC,GAC5CA,EAASA,GAAU,SACb9C,EAAMoG,SAEP,MAAMhD,KAAOP,EAAM,OAChBuE,EAAQvE,EAAKO,GACnBN,EAAOM,GAAOwG,UAAQxC,GAClBA,EAAMrF,IAAIS,GAAKI,EAAeJ,EAAGxC,EAAK8C,IACtCF,EAAewE,EAAOpH,EAAK8C,UAG1BA,GEkJPwG,YGjKa,SAASzG,OAIlB5C,EAHAD,EAAMoG,KACNW,EAAwB,MAAflE,EAAKkE,OAAiB/G,EAAI6I,gBAAgBhG,EAAKkE,aAAU8C,EAClErB,EAAwB,MAAf3F,EAAK2F,OAAiBxI,EAAI4B,IAAIiB,EAAK2F,aAAUqB,EAGtDhH,EAAKiH,OACPtB,EAASxI,EAAIkG,OAAOrD,EAAKiH,OAAQjH,EAAKhD,KAAMkH,GAErClE,EAAKkH,QAEZvB,GADAvI,EAAO4C,EAAKkH,MAAMhI,IAAIuB,GAAKtD,EAAI4B,IAAI0B,KACrB,GAAGyG,MAAMC,MAAM/J,EAAK,GAAIA,EAAKgK,MAAM,KAG/CpH,EAAKqH,UACPjK,EAAO4C,EAAKqH,QAAQnI,IAAIuB,GAAKtD,EAAI4B,IAAI0B,IACrCkF,EAASA,EAAO0B,QAAQjK,EAAK,GAAIA,EAAK,KAGpC4C,EAAKkE,SACPyB,EAASA,EAAOzB,OAAOA,IAGJ,MAAjBlE,EAAKsH,WACP3B,EAASA,EAAO2B,UAAUtH,EAAKsH,WAGZ,MAAjBtH,EAAKuH,WACP5B,EAASA,EAAO4B,UAAUvH,EAAKuH,WAGnB,MAAV5B,GACFhF,QAAM,8BAAgC6G,KAAKC,UAAUzH,IAGnDA,EAAK0H,SAAS/B,EAAO+B,SAAQ,GAEjCvK,EAAIwI,OAAO3F,EAAM2F,IH6HjBgB,YIlKa,SAAS3G,OAIlB4F,EAHAzI,EAAMoG,KACNoE,EAAQzH,WAASyH,EAAQ3H,EAAKiH,QAAUU,EAAMjH,KAAOiH,EACrDV,EAAS9J,EAAI4B,IAAI4I,GAEjBlC,EAASzF,EAAKyF,OACdxF,OAAS+G,EAERC,GAAQtG,QAAM,uBAAyBX,EAAKiH,QAEjDrB,EAAS5F,EAAK4F,QAAU5F,EAAK4F,OAAO3E,MAChC9D,EAAI6I,gBAAgBhG,EAAK4F,OAAO3E,OAChC9D,EAAI4B,IAAIiB,EAAK4F,QAEbH,GAAUA,EAAOxE,QACfwE,EAAO1E,UACTd,EAAS9C,EAAI6D,gBAAgByE,EAAO1E,UAEtC0E,EAAStI,EAAI8I,kBAAkBR,EAAOxE,QAGxC9D,EAAIsI,OAAOzF,EAAMiH,EAAQrB,EAAQH,EAAQxF,IJgJzC2H,SDtKK,SAAkB9B,OACnB3I,EAAMoG,KACNsE,EAAQ,MAER/B,EAAQlD,QAAS,KACfA,EAAWiF,EAAMjF,QAAU,GAC/Be,OAAOQ,KAAKhH,EAAIyF,SAAS0C,QAAQ/E,UACzBkC,EAAKtF,EAAIyF,QAAQrC,GACnBuF,EAAQlD,QAAQrC,EAAKkC,KACvBG,EAAQrC,GAAOkC,EAAG8B,YAKpBuB,EAAQpC,KAAM,KACZA,EAAQmE,EAAMnE,KAAO,GACzBC,OAAOQ,KAAKhH,EAAIuG,MAAM4B,QAAQ/E,UACtBuH,EAAU3K,EAAIuG,KAAKnD,GACrBuF,EAAQpC,KAAKnD,EAAKuH,KACpBpE,EAAKnD,GAAOuH,EAAQC,MAAMxD,gBAK5BpH,EAAI6G,aAAkC,IAApB8B,EAAQkC,UAC5BH,EAAM7D,WAAa7G,EAAI6G,WAAW9E,IAAI/B,GAAOA,EAAIyK,SAAS9B,KAGrD+B,GC2IPI,SDxIK,SAAkBJ,OACnB1K,EAAMoG,KACNJ,EAAKhG,EAAIkF,SACTqB,EAAOmE,EAAMnE,KACbd,EAAUiF,EAAMjF,QAEpBe,OAAOQ,KAAKvB,GAAW,IAAI0C,QAAQ/E,IACjC4C,EAAGsC,OAAOtI,EAAIyF,QAAQrC,GAAMqC,EAAQrC,GAAMyC,KAG5CW,OAAOQ,KAAKT,GAAQ,IAAI4B,QAAQ/E,IAC9B4C,EAAG0B,MACD1H,EAAIuG,KAAKnD,GAAKwH,MACd5E,EAAG2B,YAAYoD,OAAOC,UAAQpD,OAAOrB,EAAKnD,QAI7CsH,EAAM7D,YAAe,IAAIsB,QAAQ,CAAC8C,EAAU3I,WACrC8C,EAASpF,EAAI6G,WAAWvE,GAC1B8C,GAAQA,EAAO0F,SAASG,iBCpCjB,SAASjF,EAAIC,EAAY1F,EAAWG,UAC1C,IAAIqF,EAAQC,EAAIC,EAAY1F,EAAWG"}