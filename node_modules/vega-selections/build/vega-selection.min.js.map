{"version":3,"file":"vega-selection.min.js","sources":["../src/constants.js","../src/selectionTest.js","../../../node_modules/d3-array/src/bisector.js","../../../node_modules/d3-array/src/ascending.js","../src/selectionResolve.js","../src/selectionTuples.js","../src/selectionVisitor.js"],"sourcesContent":["export const Intersect = 'intersect';\nexport const Union = 'union';\nexport const VlMulti = 'vlMulti';\nexport const VlPoint = 'vlPoint';\nexport const Or = 'or';\nexport const And = 'and';\n","import {bisector} from 'd3-array';\nimport {Intersect} from './constants';\nimport {field, inrange, isArray, isDate, toNumber} from 'vega-util';\n\nconst SELECTION_ID = '_vgsid_',\n    TYPE_ENUM = 'E',\n    TYPE_RANGE_INC = 'R',\n    TYPE_RANGE_EXC = 'R-E',\n    TYPE_RANGE_LE = 'R-LE',\n    TYPE_RANGE_RE = 'R-RE',\n    UNIT_INDEX = 'index:unit';\n\n// TODO: revisit date coercion?\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      n = fields.length,\n      i = 0, dval, f;\n\n  for (; i<n; ++i) {\n    f = fields[i];\n    f.getter = field.getter || field(f.field);\n    dval = f.getter(datum);\n\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isDate(values[i][0])) values[i] = values[i].map(toNumber);\n\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if(isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) { // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *  Tuples in the dataset are of the form\n *  {unit: string, fields: array<fielddef>, values: array<*>}.\n *  Fielddef is of the form\n *  {field: string, channel: string, type: 'E' | 'R'} where\n *  'type' identifies whether tuples in the dataset enumerate\n *  values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\nexport function selectionTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      n = entries.length,\n      i = 0,\n      entry, miss, count, unit, b;\n\n  for (; i<n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit=entry.unit] || 0;\n\n      // if we've already matched this unit, skip.\n      if (count === -1) continue;\n\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count;\n\n      // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry);\n\n      // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n      if (intersect ^ b) return b;\n    }\n  }\n\n  // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n  return n && intersect;\n}\n\nconst selectionId = field(SELECTION_ID),\n  bisect = bisector(selectionId),\n  bisectLeft = bisect.left,\n  bisectRight = bisect.right;\n\nexport function selectionIdTest(name, datum, op) {\n  const data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      value = selectionId(datum),\n      index = bisectLeft(entries, value);\n\n  if (index === entries.length) return false;\n  if (selectionId(entries[index]) !== value) return false;\n\n  if (unitIdx && intersect) {\n    if (unitIdx.size === 1) return true;\n    if (bisectRight(entries, value) - index < unitIdx.size) return false;\n  }\n\n  return true;\n}\n","import ascending from \"./ascending.js\";\n\nexport default function(f) {\n  let delta = f;\n  let compare = f;\n\n  if (f.length === 1) {\n    delta = (d, x) => f(d) - x;\n    compare = ascendingComparator(f);\n  }\n\n  function left(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (compare(a[mid], x) < 0) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  function right(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1;\n      if (compare(a[mid], x) > 0) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  function center(a, x, lo, hi) {\n    if (lo == null) lo = 0;\n    if (hi == null) hi = a.length;\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction ascendingComparator(f) {\n  return (d, x) => ascending(f(d), x);\n}\n","export default function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","import {And, Or, Union, VlMulti, VlPoint} from './constants';\nimport {array, toNumber} from 'vega-util';\n\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @param {boolean} isMulti - Identifies a \"multi\" selection to perform more\n *                 expensive resolution computation.\n * @param {boolean} vl5 - With Vega-Lite v5, \"multi\" selections are now called \"point\"\n *                 selections, and thus the resolved tuple should reflect this name.\n *                 This parameter allows us to reflect this change without triggering\n *                 a major version bump for Vega.\n * @returns {object} An object of selected fields and values.\n */\nexport function selectionResolve(name, op, isMulti, vl5) {\n  var data = this.context.data[name],\n    entries = data ? data.values.value : [],\n    resolved = {}, multiRes = {}, types = {},\n    entry, fields, values, unit, field, res, resUnit, type, union,\n    n = entries.length, i = 0, j, m;\n\n  // First union all entries within the same unit.\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    for (j = 0, m = fields.length; j < m; ++j) {\n      field = fields[j];\n      res = resolved[field.field] || (resolved[field.field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      types[field.field] = type = field.type.charAt(0);\n      union = ops[type + '_union'];\n      res[unit] = union(resUnit, array(values[j]));\n    }\n\n    // If the same multi-selection is repeated over views and projected over\n    // an encoding, it may operate over different fields making it especially\n    // tricky to reliably resolve it. At best, we can de-dupe identical entries\n    // but doing so may be more computationally expensive than it is worth.\n    // Instead, for now, we simply transform our store representation into\n    // a more human-friendly one.\n    if (isMulti) {\n      resUnit = multiRes[unit] || (multiRes[unit] = []);\n      resUnit.push(array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));\n    }\n  }\n\n  // Then resolve fields across units as per the op.\n  op = op || Union;\n  Object.keys(resolved).forEach(field => {\n    resolved[field] = Object.keys(resolved[field])\n      .map(unit => resolved[field][unit])\n      .reduce((acc, curr) => acc === undefined ? curr : ops[types[field] + '_' + op](acc, curr));\n  });\n\n  entries = Object.keys(multiRes);\n  if (isMulti && entries.length) {\n    const key = vl5 ? VlPoint : VlMulti;\n    resolved[key] = op === Union\n      ? {[Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])}\n      : {[And]: entries.map(k => ({[Or]: multiRes[k]}))};\n  }\n\n  return resolved;\n}\n\nvar ops = {\n  E_union: function(base, value) {\n    if (!base.length) return value;\n\n    var i = 0, n = value.length;\n    for (; i<n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);\n    return base;\n  },\n\n  E_intersect: function(base, value) {\n    return !base.length ? value :\n      base.filter(v => value.indexOf(v) >= 0);\n  },\n\n  R_union: function(base, value) {\n    var lo = toNumber(value[0]), hi = toNumber(value[1]);\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n\n  R_intersect: function(base, value) {\n    var lo = toNumber(value[0]), hi = toNumber(value[1]);\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n    return base;\n  }\n};\n","import {extend, field} from 'vega-util';\n\n/**\n * Maps an array of scene graph items to an array of selection tuples.\n * @param {string} name  - The name of the dataset representing the selection.\n * @param {string} unit  - The name of the unit view.\n *\n * @returns {array} An array of selection entries for the given unit.\n */\nexport function selectionTuples(array, base) {\n  return array.map(x => extend({\n    values: base.fields.map(f => (f.getter || (f.getter = field(f.field)))(x.datum))\n  }, base));\n}\n","import {Intersect} from './constants';\nimport {Literal} from 'vega-expression';\nimport {error, hasOwnProperty, peek} from 'vega-util';\n\nconst DataPrefix = ':',\n      IndexPrefix = '@';\n\nexport function selectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to selection functions must be a string literal.');\n\n  const data = args[0].value,\n        op = args.length >= 2 && peek(args).value,\n        field = 'unit',\n        indexName = IndexPrefix + field,\n        dataName = DataPrefix + data;\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (op === Intersect && !hasOwnProperty(params, indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (!hasOwnProperty(params, dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}"],"names":["Intersect","Union","UNIT_INDEX","testPoint","datum","entry","dval","f","fields","values","n","length","i","getter","field","isDate","toNumber","map","type","isArray","indexOf","inrange","selectionId","bisect","delta","compare","left","a","x","lo","hi","mid","d","ascending","b","NaN","ascendingComparator","center","right","bisector","bisectLeft","bisectRight","ops","E_union","base","value","push","E_intersect","filter","v","R_union","R_intersect","name","op","data","this","context","entries","unitIdx","undefined","intersect","index","size","isMulti","vl5","unit","res","resUnit","union","j","m","resolved","multiRes","types","charAt","array","reduce","obj","curr","Object","keys","forEach","acc","k","miss","count","get","extend","args","scope","params","Literal","error","indexName","IndexPrefix","dataName","peek","hasOwnProperty","getData","indataRef","tuplesRef"],"mappings":"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"}