{"version":3,"file":"vega-view-transforms.min.js","sources":["../src/constants.js","../src/Bound.js","../src/Identifier.js","../src/Mark.js","../src/Overlap.js","../src/Render.js","../src/layout/util.js","../src/layout/axis.js","../src/layout/grid.js","../src/layout/legend.js","../src/ViewLayout.js","../src/layout/title.js"],"sourcesContent":["export const Top = 'top';\nexport const Left = 'left';\nexport const Right = 'right';\nexport const Bottom = 'bottom';\n\nexport const TopLeft = 'top-left';\nexport const TopRight = 'top-right';\nexport const BottomLeft = 'bottom-left';\nexport const BottomRight = 'bottom-right';\n\nexport const Start = 'start';\nexport const Middle = 'middle';\nexport const End = 'end';\n\nexport const X = 'x';\nexport const Y = 'y';\n\nexport const Group = 'group';\n\nexport const AxisRole = 'axis';\nexport const TitleRole = 'title';\nexport const FrameRole = 'frame';\nexport const ScopeRole = 'scope';\nexport const LegendRole = 'legend';\n\nexport const RowHeader = 'row-header';\nexport const RowFooter = 'row-footer';\nexport const RowTitle  = 'row-title';\nexport const ColHeader = 'column-header';\nexport const ColFooter = 'column-footer';\nexport const ColTitle  = 'column-title';\n\nexport const Padding = 'padding';\n\nexport const Symbols = 'symbol';\n\nexport const Fit  = 'fit';\nexport const FitX = 'fit-x';\nexport const FitY = 'fit-y';\nexport const Pad  = 'pad';\nexport const None = 'none';\n\nexport const All = 'all';\nexport const Each = 'each';\nexport const Flush = 'flush';\n\nexport const Column = 'column';\nexport const Row = 'row';\n","import {AxisRole, Group, LegendRole, TitleRole} from './constants';\nimport {Transform} from 'vega-dataflow';\nimport {Marks, boundClip} from 'vega-scenegraph';\nimport {inherits} from 'vega-util';\n\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\nexport default function Bound(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Bound, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow,\n          mark = _.mark,\n          type = mark.marktype,\n          entry = Marks[type],\n          bound = entry.bound;\n\n    let markBounds = mark.bounds, rebound;\n\n    if (entry.nested) {\n      // multi-item marks have a single bounds instance\n      if (mark.items.length) view.dirty(mark.items[0]);\n      markBounds = boundItem(mark, bound);\n      mark.items.forEach(item => {\n        item.bounds.clear().union(markBounds);\n      });\n    }\n\n    else if (type === Group || _.modified()) {\n      // operator parameters modified -> re-bound all items\n      // updates group bounds in response to modified group content\n      pulse.visit(pulse.MOD, item => view.dirty(item));\n      markBounds.clear();\n      mark.items.forEach(item => markBounds.union(boundItem(item, bound)));\n\n      // force reflow for axes/legends/titles to propagate any layout changes\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          pulse.reflow();\n      }\n    }\n\n    else {\n      // incrementally update bounds, re-bound mark as needed\n      rebound = pulse.changed(pulse.REM);\n\n      pulse.visit(pulse.ADD, item => {\n        markBounds.union(boundItem(item, bound));\n      });\n\n      pulse.visit(pulse.MOD, item => {\n        rebound = rebound || markBounds.alignsWith(item.bounds);\n        view.dirty(item);\n        markBounds.union(boundItem(item, bound));\n      });\n\n      if (rebound) {\n        markBounds.clear();\n        mark.items.forEach(item => markBounds.union(item.bounds));\n      }\n    }\n\n    // ensure mark bounds do not exceed any clipping region\n    boundClip(mark);\n\n    return pulse.modifies('bounds');\n  }\n});\n\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\nconst COUNTER_NAME = ':vega_identifier:';\n\n/**\n * Adds a unique identifier to all added tuples.\n * This transform creates a new signal that serves as an id counter.\n * As a result, the id counter is shared across all instances of this\n * transform, generating unique ids across multiple data streams. In\n * addition, this signal value can be included in a snapshot of the\n * dataflow state, enabling correct resumption of id allocation.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.as - The field name for the generated identifier.\n */\nexport default function Identifier(params) {\n  Transform.call(this, 0, params);\n}\n\nIdentifier.Definition = {\n  'type': 'Identifier',\n  'metadata': {'modifies': true},\n  'params': [\n    { 'name': 'as', 'type': 'string', 'required': true }\n  ]\n};\n\ninherits(Identifier, Transform, {\n  transform(_, pulse) {\n    const counter = getCounter(pulse.dataflow),\n          as = _.as;\n    let id = counter.value;\n\n    pulse.visit(pulse.ADD, t => (t[as] = t[as] || ++id));\n    counter.set(this.value = id);\n    return pulse;\n  }\n});\n\nfunction getCounter(view) {\n  return view._signals[COUNTER_NAME]\n     || (view._signals[COUNTER_NAME] = view.add(0));\n}\n","import {Group} from './constants';\nimport {Transform} from 'vega-dataflow';\nimport {GroupItem, Item} from 'vega-scenegraph';\nimport {inherits} from 'vega-util';\n\n/**\n * Bind scenegraph items to a scenegraph mark instance.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.markdef - The mark definition for creating the mark.\n *   This is an object of legal scenegraph mark properties which *must* include\n *   the 'marktype' property.\n */\nexport default function Mark(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Mark, Transform, {\n  transform(_, pulse) {\n    let mark = this.value;\n\n    // acquire mark on first invocation, bind context and group\n    if (!mark) {\n      mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);\n      mark.group.context = _.context;\n      if (!_.context.group) _.context.group = mark.group;\n      mark.source = this.source; // point to upstream collector\n      mark.clip = _.clip;\n      mark.interactive = _.interactive;\n      this.value = mark;\n    }\n\n    // initialize entering items\n    const Init = mark.marktype === Group ? GroupItem : Item;\n    pulse.visit(pulse.ADD, item => Init.call(item, mark));\n\n    // update clipping and/or interactive status\n    if (_.modified('clip') || _.modified('interactive')) {\n      mark.clip = _.clip;\n      mark.interactive = !!_.interactive;\n      mark.zdirty = true; // force scenegraph re-eval\n      pulse.reflow();\n    }\n\n    // bind items array to scenegraph mark\n    mark.items = pulse.source;\n    return pulse;\n  }\n});\n\nfunction lookup(_) {\n  const g = _.groups, p = _.parent;\n  return g && g.size === 1 ? g.get(Object.keys(g.object)[0])\n    : g && p ? g.lookup(p)\n    : null;\n}\n","import {Bottom, Top} from './constants';\nimport {Transform} from 'vega-dataflow';\nimport {Bounds} from 'vega-scenegraph';\nimport {inherits, peek} from 'vega-util';\n\n/**\n * Analyze items for overlap, changing opacity to hide items with\n * overlapping bounding boxes. This transform will preserve at least\n * two items (e.g., first and last) even if overlap persists.\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting items.\n * @param {object} [params.method] - The overlap removal method to apply.\n *   One of 'parity' (default, hide every other item until there is no\n *   more overlap) or 'greedy' (sequentially scan and hide and items that\n *   overlap with the last visible item).\n * @param {object} [params.boundScale] - A scale whose range should be used\n *   to bound the items. Items exceeding the bounds of the scale range\n *   will be treated as overlapping. If null or undefined, no bounds check\n *   will be applied.\n * @param {object} [params.boundOrient] - The orientation of the scale\n *   (top, bottom, left, or right) used to bound items. This parameter is\n *   ignored if boundScale is null or undefined.\n * @param {object} [params.boundTolerance] - The tolerance in pixels for\n *   bound inclusion testing (default 1). This specifies by how many pixels\n *   an item's bounds may exceed the scale range bounds and not be culled.\n * @constructor\n */\nexport default function Overlap(params) {\n  Transform.call(this, null, params);\n}\n\nconst methods = {\n  parity: items =>\n    items.filter((item, i) => i % 2 ? (item.opacity = 0) : 1),\n  greedy: (items, sep) => {\n    let a;\n    return items.filter((b, i) =>\n      (!i || !intersect(a.bounds, b.bounds, sep))\n        ? (a = b, 1)\n        : (b.opacity = 0)\n    );\n  }\n};\n\n// compute bounding box intersection\n// including padding pixels of separation\nconst intersect = (a, b, sep) =>\n  sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);\n\nconst hasOverlap = (items, pad) => {\n  for (var i=1, n=items.length, a=items[0].bounds, b; i<n; a=b, ++i) {\n    if (intersect(a, b = items[i].bounds, pad)) return true;\n  }\n};\n\nconst hasBounds = item => {\n  const b = item.bounds;\n  return b.width() > 1 && b.height() > 1;\n};\n\nconst boundTest = (scale, orient, tolerance) => {\n  var range = scale.range(),\n      b = new Bounds();\n\n  if (orient === Top || orient === Bottom) {\n    b.set(range[0], -Infinity, range[1], +Infinity);\n  } else {\n    b.set(-Infinity, range[0], +Infinity, range[1]);\n  }\n  b.expand(tolerance || 1);\n\n  return item => b.encloses(item.bounds);\n};\n\n// reset all items to be fully opaque\nconst reset = source => {\n  source.forEach(item => item.opacity = 1);\n  return source;\n};\n\n// add all tuples to mod, fork pulse if parameters were modified\n// fork prevents cross-stream tuple pollution (e.g., pulse from scale)\nconst reflow = (pulse, _) =>\n  pulse.reflow(_.modified()).modifies('opacity');\n\ninherits(Overlap, Transform, {\n  transform(_, pulse) {\n    const reduce = methods[_.method] || methods.parity,\n          sep = _.separation || 0;\n\n    let source = pulse.materialize(pulse.SOURCE).source,\n        items, test;\n\n    if (!source || !source.length) return;\n\n    if (!_.method) {\n      // early exit if method is falsy\n      if (_.modified('method')) {\n        reset(source);\n        pulse = reflow(pulse, _);\n      }\n      return pulse;\n    }\n\n    // skip labels with no content\n    source = source.filter(hasBounds);\n\n    // early exit, nothing to do\n    if (!source.length) return;\n\n    if (_.sort) {\n      source = source.slice().sort(_.sort);\n    }\n\n    items = reset(source);\n    pulse = reflow(pulse, _);\n\n    if (items.length >= 3 && hasOverlap(items, sep)) {\n      do {\n        items = reduce(items, sep);\n      } while (items.length >= 3 && hasOverlap(items, sep));\n\n      if (items.length < 3 && !peek(source).opacity) {\n        if (items.length > 1) peek(items).opacity = 0;\n        peek(source).opacity = 1;\n      }\n    }\n\n    if (_.boundScale && _.boundTolerance >= 0) {\n      test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);\n      source.forEach(item => {\n        if (!test(item)) item.opacity = 0;\n      });\n    }\n\n    // re-calculate mark bounds\n    const bounds = items[0].mark.bounds.clear();\n    source.forEach(item => {\n      if (item.opacity) bounds.union(item.bounds);\n    });\n\n    return pulse;\n  }\n});\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Queue modified scenegraph items for rendering.\n * @constructor\n */\nexport default function Render(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Render, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n\n    pulse.visit(pulse.ALL, item => view.dirty(item));\n\n    // set z-index dirty flag as needed\n    if (pulse.fields && pulse.fields['zindex']) {\n      const item = pulse.source && pulse.source[0];\n      if (item) item.mark.zdirty = true;\n    }\n  }\n});\n","import {Bounds} from 'vega-scenegraph';\n\nexport const tempBounds = new Bounds();\n\nexport function set(item, property, value) {\n  return item[property] === value ? 0\n    : (item[property] = value, 1);\n}","import {Bottom, Left, Right, Top} from '../constants';\nimport {set, tempBounds} from './util';\nimport {boundStroke, multiLineOffset} from 'vega-scenegraph';\n\nexport function isYAxis(mark) {\n  var orient = mark.items[0].orient;\n  return orient === Left || orient === Right;\n}\n\nfunction axisIndices(datum) {\n  let index = +datum.grid;\n  return [\n    datum.ticks  ? index++ : -1, // ticks index\n    datum.labels ? index++ : -1, // labels index\n    index + (+datum.domain)      // title index\n  ];\n}\n\nexport function axisLayout(view, axis, width, height) {  \n  var item = axis.items[0],\n      datum = item.datum,\n      delta = item.translate != null ? item.translate : 0.5,\n      orient = item.orient,\n      indices = axisIndices(datum),\n      range = item.range,\n      offset = item.offset,\n      position = item.position,\n      minExtent = item.minExtent,\n      maxExtent = item.maxExtent,\n      title = datum.title && item.items[indices[2]].items[0],\n      titlePadding = item.titlePadding,\n      bounds = item.bounds,\n      dl = title && multiLineOffset(title),\n      x = 0, y = 0, i, s;\n\n  tempBounds.clear().union(bounds);\n  bounds.clear();\n  if ((i=indices[0]) > -1) bounds.union(item.items[i].bounds);\n  if ((i=indices[1]) > -1) bounds.union(item.items[i].bounds);\n\n  // position axis group and title\n  switch (orient) {\n    case Top:\n      x = position || 0;\n      y = -offset;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));\n      bounds.add(0, -s).add(range, 0);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);\n      break;\n    case Left:\n      x = -offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));\n      bounds.add(-s, 0).add(0, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);\n      break;\n    case Right:\n      x = width + offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));\n      bounds.add(0, 0).add(s, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);\n      break;\n    case Bottom:\n      x = position || 0;\n      y = height + offset;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));\n      bounds.add(0, 0).add(range, s);\n      if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);\n      break;\n    default:\n      x = item.x;\n      y = item.y;\n  }\n\n  // update bounds\n  boundStroke(bounds.translate(x, y), item);\n\n  if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n\n  return item.mark.bounds.clear().union(bounds);\n}\n\nfunction axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {\n  const b = title.bounds;\n\n  if (title.auto) {\n    const v = sign * (offset + dl + pad);\n    let dx = 0, dy = 0;\n\n    view.dirty(title);\n    isYAxis\n      ? dx = (title.x || 0) - (title.x = v)\n      : dy = (title.y || 0) - (title.y = v);\n    title.mark.bounds.clear().union(b.translate(-dx, -dy));\n    view.dirty(title);\n  }\n\n  bounds.union(b);\n}\n","import {\n  All, AxisRole, ColFooter, ColHeader, ColTitle, Column, Each, End, Flush,\n  Group, LegendRole, Middle, Row,\n  RowFooter, RowHeader, RowTitle,\n  TitleRole, X, Y\n} from '../constants';\nimport {tempBounds} from './util';\nimport {Bounds} from 'vega-scenegraph';\nimport {isObject} from 'vega-util';\n\n// aggregation functions for grid margin determination\nconst min = (a, b) => Math.floor(Math.min(a, b));\nconst max = (a, b) => Math.ceil(Math.max(a, b));\n\nfunction gridLayoutGroups(group) {\n  var groups = group.items,\n      n = groups.length,\n      i = 0, mark, items;\n\n  const views = {\n    marks:      [],\n    rowheaders: [],\n    rowfooters: [],\n    colheaders: [],\n    colfooters: [],\n    rowtitle: null,\n    coltitle: null\n  };\n\n  // layout axes, gather legends, collect bounds\n  for (; i<n; ++i) {\n    mark = groups[i];\n    items = mark.items;\n    if (mark.marktype === Group) {\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          break;\n        case RowHeader: views.rowheaders.push(...items); break;\n        case RowFooter: views.rowfooters.push(...items); break;\n        case ColHeader: views.colheaders.push(...items); break;\n        case ColFooter: views.colfooters.push(...items); break;\n        case RowTitle:  views.rowtitle = items[0]; break;\n        case ColTitle:  views.coltitle = items[0]; break;\n        default:        views.marks.push(...items);\n      }\n    }\n  }\n\n  return views;\n}\n\nfunction bboxFlush(item) {\n  return new Bounds().set(0, 0, item.width || 0, item.height || 0);\n}\n\nfunction bboxFull(item) {\n  const b = item.bounds.clone();\n  return b.empty()\n    ? b.set(0, 0, 0, 0)\n    : b.translate(-(item.x || 0), -(item.y || 0));\n}\n\nfunction get(opt, key, d) {\n  const v = isObject(opt) ? opt[key] : opt;\n  return v != null ? v : (d !== undefined ? d : 0);\n}\n\nfunction offsetValue(v) {\n  return v < 0 ? Math.ceil(-v) : 0;\n}\n\nexport function gridLayout(view, groups, opt) {\n  var dirty = !opt.nodirty,\n      bbox = opt.bounds === Flush ? bboxFlush : bboxFull,\n      bounds = tempBounds.set(0, 0, 0, 0),\n      alignCol = get(opt.align, Column),\n      alignRow = get(opt.align, Row),\n      padCol = get(opt.padding, Column),\n      padRow = get(opt.padding, Row),\n      ncols = opt.columns || groups.length,\n      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n      n = groups.length,\n      xOffset = Array(n), xExtent = Array(ncols), xMax = 0,\n      yOffset = Array(n), yExtent = Array(nrows), yMax = 0,\n      dx = Array(n), dy = Array(n), boxes = Array(n),\n      m, i, c, r, b, g, px, py, x, y, offset;\n\n  for (i=0; i<ncols; ++i) xExtent[i] = 0;\n  for (i=0; i<nrows; ++i) yExtent[i] = 0;\n\n  // determine offsets for each group\n  for (i=0; i<n; ++i) {\n    g = groups[i];\n    b = boxes[i] = bbox(g);\n    g.x = g.x || 0; dx[i] = 0;\n    g.y = g.y || 0; dy[i] = 0;\n    c = i % ncols;\n    r = ~~(i / ncols);\n    xMax = Math.max(xMax, px = Math.ceil(b.x2));\n    yMax = Math.max(yMax, py = Math.ceil(b.y2));\n    xExtent[c] = Math.max(xExtent[c], px);\n    yExtent[r] = Math.max(yExtent[r], py);\n    xOffset[i] = padCol + offsetValue(b.x1);\n    yOffset[i] = padRow + offsetValue(b.y1);\n    if (dirty) view.dirty(groups[i]);\n  }\n\n  // set initial alignment offsets\n  for (i=0; i<n; ++i) {\n    if (i % ncols === 0) xOffset[i] = 0;\n    if (i < ncols) yOffset[i] = 0;\n  }\n\n  // enforce column alignment constraints\n  if (alignCol === Each) {\n    for (c=1; c<ncols; ++c) {\n      for (offset=0, i=c; i<n; i += ncols) {\n        if (offset < xOffset[i]) offset = xOffset[i];\n      }\n      for (i=c; i<n; i += ncols) {\n        xOffset[i] = offset + xExtent[c-1];\n      }\n    }\n  } else if (alignCol === All) {\n    for (offset=0, i=0; i<n; ++i) {\n      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\n    }\n    for (i=0; i<n; ++i) {\n      if (i % ncols) xOffset[i] = offset + xMax;\n    }\n  } else {\n    for (alignCol=false, c=1; c<ncols; ++c) {\n      for (i=c; i<n; i += ncols) {\n        xOffset[i] += xExtent[c-1];\n      }\n    }\n  }\n\n  // enforce row alignment constraints\n  if (alignRow === Each) {\n    for (r=1; r<nrows; ++r) {\n      for (offset=0, i=r*ncols, m=i+ncols; i<m; ++i) {\n        if (offset < yOffset[i]) offset = yOffset[i];\n      }\n      for (i=r*ncols; i<m; ++i) {\n        yOffset[i] = offset + yExtent[r-1];\n      }\n    }\n  } else if (alignRow === All) {\n    for (offset=0, i=ncols; i<n; ++i) {\n      if (offset < yOffset[i]) offset = yOffset[i];\n    }\n    for (i=ncols; i<n; ++i) {\n      yOffset[i] = offset + yMax;\n    }\n  } else {\n    for (alignRow=false, r=1; r<nrows; ++r) {\n      for (i=r*ncols, m=i+ncols; i<m; ++i) {\n        yOffset[i] += yExtent[r-1];\n      }\n    }\n  }\n\n  // perform horizontal grid layout\n  for (x=0, i=0; i<n; ++i) {\n    x = xOffset[i] + (i % ncols ? x : 0);\n    dx[i] += x - groups[i].x;\n  }\n\n  // perform vertical grid layout\n  for (c=0; c<ncols; ++c) {\n    for (y=0, i=c; i<n; i += ncols) {\n      y += yOffset[i];\n      dy[i] += y - groups[i].y;\n    }\n  }\n\n  // perform horizontal centering\n  if (alignCol && get(opt.center, Column) && nrows > 1) {\n    for (i=0; i<n; ++i) {\n      b = alignCol === All ? xMax : xExtent[i % ncols];\n      x = b - boxes[i].x2 - groups[i].x - dx[i];\n      if (x > 0) dx[i] += x / 2;\n    }\n  }\n\n  // perform vertical centering\n  if (alignRow && get(opt.center, Row) && ncols !== 1) {\n    for (i=0; i<n; ++i) {\n      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\n      y = b - boxes[i].y2 - groups[i].y - dy[i];\n      if (y > 0) dy[i] += y / 2;\n    }\n  }\n\n  // position grid relative to anchor\n  for (i=0; i<n; ++i) {\n    bounds.union(boxes[i].translate(dx[i], dy[i]));\n  }\n  x = get(opt.anchor, X);\n  y = get(opt.anchor, Y);\n  switch (get(opt.anchor, Column)) {\n    case End:    x -= bounds.width(); break;\n    case Middle: x -= bounds.width() / 2;\n  }\n  switch (get(opt.anchor, Row)) {\n    case End:    y -= bounds.height(); break;\n    case Middle: y -= bounds.height() / 2;\n  }\n  x = Math.round(x);\n  y = Math.round(y);\n\n  // update mark positions, bounds, dirty\n  bounds.clear();\n  for (i=0; i<n; ++i) {\n    groups[i].mark.bounds.clear();\n  }\n  for (i=0; i<n; ++i) {\n    g = groups[i];\n    g.x += (dx[i] += x);\n    g.y += (dy[i] += y);\n    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));\n    if (dirty) view.dirty(g);\n  }\n\n  return bounds;\n}\n\nexport function trellisLayout(view, group, opt) {\n  var views = gridLayoutGroups(group),\n      groups = views.marks,\n      bbox = opt.bounds === Flush ? boundFlush : boundFull,\n      off = opt.offset,\n      ncols = opt.columns || groups.length,\n      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n      cells = nrows * ncols,\n      x, y, x2, y2, anchor, band, offset;\n\n  // -- initial grid layout\n  const bounds = gridLayout(view, groups, opt);\n  if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid\n\n  // -- layout grid headers and footers --\n\n  // perform row header layout\n  if (views.rowheaders) {\n    band = get(opt.headerBand, Row, null);\n    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);\n  }\n\n  // perform column header layout\n  if (views.colheaders) {\n    band = get(opt.headerBand, Column, null);\n    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\n  }\n\n  // perform row footer layout\n  if (views.rowfooters) {\n    band = get(opt.footerBand, Row, null);\n    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows,  get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols-1, ncols, 1, band);\n  }\n\n  // perform column footer layout\n  if (views.colfooters) {\n    band = get(opt.footerBand, Column, null);\n    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols,  get(off, 'columnFooter'), max, 1, bbox, 'y2', cells-ncols, 1, ncols, band);\n  }\n\n  // perform row title layout\n  if (views.rowtitle) {\n    anchor = get(opt.titleAnchor, Row);\n    offset = get(off, 'rowTitle');\n    offset = anchor === End ? x2 + offset : x - offset;\n    band = get(opt.titleBand, Row, 0.5);\n    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\n  }\n\n  // perform column title layout\n  if (views.coltitle) {\n    anchor = get(opt.titleAnchor, Column);\n    offset = get(off, 'columnTitle');\n    offset = anchor === End ? y2 + offset : y - offset;\n    band = get(opt.titleBand, Column, 0.5);\n    layoutTitle(view, views.coltitle, offset, 1, bounds, band);\n  }\n}\n\nfunction boundFlush(item, field) {\n  return field === 'x1' ? (item.x || 0)\n    : field === 'y1' ? (item.y || 0)\n    : field === 'x2' ? (item.x || 0) + (item.width || 0)\n    : field === 'y2' ? (item.y || 0) + (item.height || 0)\n    : undefined;\n}\n\nfunction boundFull(item, field) {\n  return item.bounds[field];\n}\n\nfunction layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\n  var n = groups.length,\n      init = 0,\n      edge = 0,\n      i, j, k, m, b, h, g, x, y;\n\n  // if no groups, early exit and return 0\n  if (!n) return init;\n\n  // compute margin\n  for (i=start; i<n; i+=stride) {\n    if (groups[i]) init = agg(init, bound(groups[i], bf));\n  }\n\n  // if no headers, return margin calculation\n  if (!headers.length) return init;\n\n  // check if number of headers exceeds number of rows or columns\n  if (headers.length > limit) {\n    view.warn('Grid headers exceed limit: ' + limit);\n    headers = headers.slice(0, limit);\n  }\n\n  // apply offset\n  init += offset;\n\n  // clear mark bounds for all headers\n  for (j=0, m=headers.length; j<m; ++j) {\n    view.dirty(headers[j]);\n    headers[j].mark.bounds.clear();\n  }\n\n  // layout each header\n  for (i=start, j=0, m=headers.length; j<m; ++j, i+=stride) {\n    h = headers[j];\n    b = h.mark.bounds;\n\n    // search for nearest group to align to\n    // necessary if table has empty cells\n    for (k=i; k >= 0 && (g = groups[k]) == null; k-=back);\n\n    // assign coordinates and update bounds\n    if (isX) {\n      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\n      y = init;\n    } else {\n      x = init;\n      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\n    }\n    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\n    h.x = x;\n    h.y = y;\n    view.dirty(h);\n\n    // update current edge of layout bounds\n    edge = agg(edge, b[bf]);\n  }\n\n  return edge;\n}\n\nfunction layoutTitle(view, g, offset, isX, bounds, band) {\n  if (!g) return;\n  view.dirty(g);\n\n  // compute title coordinates\n  var x = offset, y = offset;\n  isX\n    ? (x = Math.round(bounds.x1 + band * bounds.width()))\n    : (y = Math.round(bounds.y1 + band * bounds.height()));\n\n  // assign coordinates and update bounds\n  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\n  g.mark.bounds.clear().union(g.bounds);\n  g.x = x;\n  g.y = y;\n\n  // queue title for redraw\n  view.dirty(g);\n}\n","import {\n  Bottom, BottomLeft, BottomRight, Each, End, Flush, Left, Middle,\n  None, Right, Start, Symbols, Top,\n  TopLeft, TopRight\n} from '../constants';\nimport {boundStroke, multiLineOffset} from 'vega-scenegraph';\n\n// utility for looking up legend layout configuration\nfunction lookup(config, orient) {\n  const opt = config[orient] || {};\n  return (key, d) => opt[key] != null ? opt[key]\n    : config[key] != null ? config[key]\n    : d;\n}\n\n// if legends specify offset directly, use the maximum specified value\nfunction offsets(legends, value) {\n  let max = -Infinity;\n  legends.forEach(item => {\n    if (item.offset != null) max = Math.max(max, item.offset);\n  });\n  return max > -Infinity ? max : value;\n}\n\nexport function legendParams(g, orient, config, xb, yb, w, h) {\n  const _ = lookup(config, orient),\n        offset = offsets(g, _('offset', 0)),\n        anchor = _('anchor', Start),\n        mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;\n\n  const p = {\n    align:   Each,\n    bounds:  _('bounds', Flush),\n    columns: _('direction') === 'vertical' ? 1 : g.length,\n    padding: _('margin', 8),\n    center:  _('center'),\n    nodirty: true\n  };\n\n  switch (orient) {\n    case Left:\n      p.anchor = {\n        x: Math.floor(xb.x1) - offset, column: End,\n        y: mult * (h || xb.height() + 2 * xb.y1), row: anchor\n      };\n      break;\n    case Right:\n      p.anchor = {\n        x: Math.ceil(xb.x2) + offset,\n        y: mult * (h || xb.height() + 2 * xb.y1), row: anchor\n      };\n      break;\n    case Top:\n      p.anchor = {\n        y: Math.floor(yb.y1) - offset, row: End,\n        x: mult * (w || yb.width() + 2 * yb.x1), column: anchor\n      };\n      break;\n    case Bottom:\n      p.anchor = {\n        y: Math.ceil(yb.y2) + offset,\n        x: mult * (w || yb.width() + 2 * yb.x1), column: anchor\n      };\n      break;\n    case TopLeft:\n      p.anchor = {x: offset, y: offset};\n      break;\n    case TopRight:\n      p.anchor = {x: w - offset, y: offset, column: End};\n      break;\n    case BottomLeft:\n      p.anchor = {x: offset, y: h - offset, row: End};\n      break;\n    case BottomRight:\n      p.anchor = {x: w - offset, y: h - offset, column: End, row: End};\n      break;\n  }\n\n  return p;\n}\n\nexport function legendLayout(view, legend) {\n  var item = legend.items[0],\n      datum = item.datum,\n      orient = item.orient,\n      bounds = item.bounds,\n      x = item.x, y = item.y, w, h;\n\n  // cache current bounds for later comparison\n  item._bounds\n    ? item._bounds.clear().union(bounds)\n    : item._bounds = bounds.clone();\n  bounds.clear();\n\n  // adjust legend to accommodate padding and title\n  legendGroupLayout(view, item, item.items[0].items[0]);\n\n  // aggregate bounds to determine size, and include origin\n  bounds = legendBounds(item, bounds);\n  w = 2 * item.padding;\n  h = 2 * item.padding;\n  if (!bounds.empty()) {\n    w = Math.ceil(bounds.width() + w);\n    h = Math.ceil(bounds.height() + h);\n  }\n\n  if (datum.type === Symbols) {\n    legendEntryLayout(item.items[0].items[0].items[0].items);\n  }\n\n  if (orient !== None) {\n    item.x = x = 0;\n    item.y = y = 0;\n  }\n  item.width = w;\n  item.height = h;\n  boundStroke(bounds.set(x, y, x + w, y + h), item);\n  item.mark.bounds.clear().union(bounds);\n\n  return item;\n}\n\nfunction legendBounds(item, b) {\n  // aggregate item bounds\n  item.items.forEach(_ => b.union(_.bounds));\n\n  // anchor to legend origin\n  b.x1 = item.padding;\n  b.y1 = item.padding;\n\n  return b;\n}\n\nfunction legendGroupLayout(view, item, entry) {\n  var pad = item.padding,\n      ex = pad - entry.x,\n      ey = pad - entry.y;\n\n  if (!item.datum.title) {\n    if (ex || ey) translate(view, entry, ex, ey);\n  } else {\n    var title = item.items[1].items[0],\n        anchor = title.anchor,\n        tpad = item.titlePadding || 0,\n        tx = pad - title.x,\n        ty = pad - title.y;\n\n    switch (title.orient) {\n      case Left:\n        ex += Math.ceil(title.bounds.width()) + tpad;\n        break;\n      case Right:\n      case Bottom:\n        break;\n      default:\n        ey += title.bounds.height() + tpad;\n    }\n    if (ex || ey) translate(view, entry, ex, ey);\n\n    switch (title.orient) {\n      case Left:\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n      case Right:\n        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n      case Bottom:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;\n        break;\n      default:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n    }\n    if (tx || ty) translate(view, title, tx, ty);\n\n    // translate legend if title pushes into negative coordinates\n    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {\n      translate(view, entry, -tx, 0);\n      translate(view, title, -tx, 0);\n    }\n  }\n}\n\nfunction legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {\n  const grad = item.datum.type !== 'symbol',\n        vgrad = title.datum.vgrad,\n        e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,\n        s = e.bounds[y ? 'y2' : 'x2'] - item.padding,\n        u = vgrad && lr ? s : 0,\n        v = vgrad && lr ? 0 : s,\n        o = y <= 0 ? 0 : multiLineOffset(title);\n\n  return Math.round(anchor === Start ? u\n    : anchor === End ? (v - o)\n    : 0.5 * (s - o));\n}\n\nfunction translate(view, item, dx, dy) {\n  item.x += dx;\n  item.y += dy;\n  item.bounds.translate(dx, dy);\n  item.mark.bounds.translate(dx, dy);\n  view.dirty(item);\n}\n\nfunction legendEntryLayout(entries) {\n  // get max widths for each column\n  const widths = entries.reduce((w, g) => {\n    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\n    return w;\n  }, {});\n\n  // set dimensions of legend entry groups\n  entries.forEach(g => {\n    g.width  = widths[g.column];\n    g.height = g.bounds.y2 - g.y;\n  });\n}\n","import {\n  AxisRole, Bottom, ColFooter, ColHeader, ColTitle,\n  Fit, FitX, FitY, FrameRole, Left, LegendRole,\n  None, Pad, Padding, Right,\n  RowFooter, RowHeader, RowTitle, ScopeRole, TitleRole, Top\n} from './constants';\n\nimport {axisLayout, isYAxis} from './layout/axis';\nimport {gridLayout, trellisLayout} from './layout/grid';\nimport {legendLayout, legendParams} from './layout/legend';\nimport {titleLayout} from './layout/title';\n\nimport {Transform} from 'vega-dataflow';\nimport {Bounds} from 'vega-scenegraph';\nimport {inherits} from 'vega-util';\n\n/**\n * Layout view elements such as axes and legends.\n * Also performs size adjustments.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - Scenegraph mark of groups to layout.\n */\nexport default function ViewLayout(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(ViewLayout, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n    _.mark.items.forEach(group => {\n      if (_.layout) trellisLayout(view, group, _.layout);\n      layoutGroup(view, group, _);\n    });\n    return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;\n  }\n});\n\nfunction shouldReflow(group) {\n  // We typically should reflow if layout is invoked (#2568), as child items\n  // may have resized and reflow ensures group bounds are re-calculated.\n  // However, legend entries have a special exception to avoid instability.\n  // For example, if a selected legend symbol gains a stroke on hover,\n  // we don't want to re-position subsequent elements in the legend.\n  return group && group.mark.role !== 'legend-entry';\n}\n\nfunction layoutGroup(view, group, _) {\n  var items = group.items,\n      width = Math.max(0, group.width || 0),\n      height = Math.max(0, group.height || 0),\n      viewBounds = new Bounds().set(0, 0, width, height),\n      xBounds = viewBounds.clone(),\n      yBounds = viewBounds.clone(),\n      legends = [], title,\n      mark, orient, b, i, n;\n\n  // layout axes, gather legends, collect bounds\n  for (i=0, n=items.length; i<n; ++i) {\n    mark = items[i];\n    switch (mark.role) {\n      case AxisRole:\n        b = isYAxis(mark) ? xBounds : yBounds;\n        b.union(axisLayout(view, mark, width, height));\n        break;\n      case TitleRole:\n        title = mark;\n        break;\n      case LegendRole:\n        legends.push(legendLayout(view, mark));\n        break;\n      case FrameRole:\n      case ScopeRole:\n      case RowHeader:\n      case RowFooter:\n      case RowTitle:\n      case ColHeader:\n      case ColFooter:\n      case ColTitle:\n        xBounds.union(mark.bounds);\n        yBounds.union(mark.bounds);\n        break;\n      default:\n        viewBounds.union(mark.bounds);\n    }\n  }\n\n  // layout legends, adjust viewBounds\n  if (legends.length) {\n    // group legends by orient\n    const l = {};\n    legends.forEach(item => {\n      orient = item.orient || Right;\n      if (orient !== None) (l[orient] || (l[orient] = [])).push(item);\n    });\n\n    // perform grid layout for each orient group\n    for (const orient in l) {\n      const g = l[orient];\n      gridLayout(view, g, legendParams(\n        g, orient, _.legends, xBounds, yBounds, width, height\n      ));\n    }\n\n    // update view bounds\n    legends.forEach(item => {\n      const b = item.bounds;\n\n      if (!b.equals(item._bounds)) {\n        item.bounds = item._bounds;\n        view.dirty(item); // dirty previous location\n        item.bounds = b;\n        view.dirty(item);\n      }\n\n      if (_.autosize && _.autosize.type === Fit) {\n        // For autosize fit, incorporate the orthogonal dimension only.\n        // Legends that overrun the chart area will then be clipped;\n        // otherwise the chart area gets reduced to nothing!\n        switch(item.orient) {\n          case Left:\n          case Right:\n            viewBounds.add(b.x1, 0).add(b.x2, 0);\n            break;\n          case Top:\n          case Bottom:\n            viewBounds.add(0, b.y1).add(0, b.y2);\n        }\n      } else {\n        viewBounds.union(b);\n      }\n    });\n  }\n\n  // combine bounding boxes\n  viewBounds.union(xBounds).union(yBounds);\n\n  // layout title, adjust bounds\n  if (title) {\n    viewBounds.union(titleLayout(view, title, width, height, viewBounds));\n  }\n\n  // override aggregated view bounds if content is clipped\n  if (group.clip) {\n    viewBounds.set(0, 0, group.width || 0, group.height || 0);\n  }\n\n  // perform size adjustment\n  viewSizeLayout(view, group, viewBounds, _);\n}\n\nfunction viewSizeLayout(view, group, viewBounds, _) {\n  const auto = _.autosize || {},\n        type = auto.type;\n\n  if (view._autosize < 1 || !type) return;\n\n  let viewWidth = view._width,\n      viewHeight = view._height,\n      width  = Math.max(0, group.width || 0),\n      left   = Math.max(0, Math.ceil(-viewBounds.x1)),\n      height = Math.max(0, group.height || 0),\n      top    = Math.max(0, Math.ceil(-viewBounds.y1));\n\n  const right  = Math.max(0, Math.ceil(viewBounds.x2 - width)),\n        bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));\n\n  if (auto.contains === Padding) {\n    const padding = view.padding();\n    viewWidth -= padding.left + padding.right;\n    viewHeight -= padding.top + padding.bottom;\n  }\n\n  if (type === None) {\n    left = 0;\n    top = 0;\n    width = viewWidth;\n    height = viewHeight;\n  }\n\n  else if (type === Fit) {\n    width = Math.max(0, viewWidth - left - right);\n    height = Math.max(0, viewHeight - top - bottom);\n  }\n\n  else if (type === FitX) {\n    width = Math.max(0, viewWidth - left - right);\n    viewHeight = height + top + bottom;\n  }\n\n  else if (type === FitY) {\n    viewWidth = width + left + right;\n    height = Math.max(0, viewHeight - top - bottom);\n  }\n\n  else if (type === Pad) {\n    viewWidth = width + left + right;\n    viewHeight = height + top + bottom;\n  }\n\n  view._resizeView(\n    viewWidth, viewHeight,\n    width, height,\n    [left, top],\n    auto.resize\n  );\n}\n","import {Bottom, End, Group, Left, Right, Start, Top} from '../constants';\nimport {set, tempBounds} from './util';\n\nexport function titleLayout(view, mark, width, height, viewBounds) {\n  var group = mark.items[0],\n      frame = group.frame,\n      orient = group.orient,\n      anchor = group.anchor,\n      offset = group.offset,\n      padding = group.padding,\n      title = group.items[0].items[0],\n      subtitle = group.items[1] && group.items[1].items[0],\n      end = (orient === Left || orient === Right) ? height : width,\n      start = 0, x = 0, y = 0, sx = 0, sy = 0, pos;\n\n  if (frame !== Group) {\n    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1)\n      : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2)\n      : (start = viewBounds.x1, end = viewBounds.x2);\n  } else if (orient === Left) {\n    start = height, end = 0;\n  }\n\n  pos = (anchor === Start) ? start\n    : (anchor === End) ? end\n    : (start + end) / 2;\n\n  if (subtitle && subtitle.text) {\n    // position subtitle\n    switch (orient) {\n      case Top:\n      case Bottom:\n        sy = title.bounds.height() + padding;\n        break;\n      case Left:\n        sx = title.bounds.width() + padding;\n        break;\n      case Right:\n        sx = -title.bounds.width() - padding;\n        break;\n    }\n\n    tempBounds.clear().union(subtitle.bounds);\n    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));\n    if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {\n      view.dirty(subtitle);\n      subtitle.bounds.clear().union(tempBounds);\n      subtitle.mark.bounds.clear().union(tempBounds);\n      view.dirty(subtitle);\n    }\n\n    tempBounds.clear().union(subtitle.bounds);\n  } else {\n    tempBounds.clear();\n  }\n  tempBounds.union(title.bounds);\n\n  // position title group\n  switch (orient) {\n    case Top:\n      x = pos;\n      y = viewBounds.y1 - tempBounds.height() - offset;\n      break;\n    case Left:\n      x = viewBounds.x1 - tempBounds.width() - offset;\n      y = pos;\n      break;\n    case Right:\n      x = viewBounds.x2 + tempBounds.width() + offset;\n      y = pos;\n      break;\n    case Bottom:\n      x = pos;\n      y = viewBounds.y2 + offset;\n      break;\n    default:\n      x = group.x;\n      y = group.y;\n  }\n\n  if (set(group, 'x', x) | set(group, 'y', y)) {\n    tempBounds.translate(x, y);\n    view.dirty(group);\n    group.bounds.clear().union(tempBounds);\n    mark.bounds.clear().union(tempBounds);\n    view.dirty(group);\n  }\n  return group.bounds;\n}\n"],"names":["Top","Left","Right","Bottom","Start","Middle","End","Group","AxisRole","TitleRole","FrameRole","ScopeRole","LegendRole","RowHeader","RowFooter","RowTitle","ColHeader","ColFooter","ColTitle","Padding","Fit","FitX","FitY","None","All","Each","Flush","Column","Row","Bound","params","Transform","call","this","boundItem","item","bound","opt","bounds","clear","transform","_","pulse","view","dataflow","mark","type","marktype","entry","Marks","rebound","markBounds","nested","items","length","dirty","forEach","union","modified","visit","MOD","role","reflow","changed","REM","ADD","alignsWith","boundClip","modifies","COUNTER_NAME","Identifier","Mark","Overlap","Definition","counter","_signals","add","as","id","value","t","set","scenegraph","markdef","g","groups","p","parent","size","get","Object","keys","object","lookup","index","group","context","source","clip","interactive","Init","GroupItem","Item","zdirty","methods","parity","filter","i","opacity","greedy","sep","a","b","intersect","Math","max","x1","x2","y1","y2","hasOverlap","pad","n","hasBounds","width","height","reset","Render","reduce","method","separation","test","materialize","SOURCE","sort","slice","peek","scale","orient","tolerance","range","boundScale","boundTolerance","boundOrient","Bounds","expand","encloses","ALL","fields","tempBounds","property","isYAxis","axisLayout","axis","s","datum","delta","translate","indices","grid","ticks","labels","domain","axisIndices","offset","position","minExtent","maxExtent","title","titlePadding","dl","multiLineOffset","x","y","min","axisTitleLayout","boundStroke","sign","auto","v","dx","dy","floor","ceil","bboxFlush","bboxFull","clone","empty","key","d","isObject","undefined","offsetValue","gridLayout","m","c","r","px","py","nodirty","bbox","alignCol","align","alignRow","padCol","padding","padRow","ncols","columns","nrows","xOffset","Array","xExtent","xMax","yOffset","yExtent","yMax","boxes","center","anchor","round","trellisLayout","band","views","marks","rowheaders","rowfooters","colheaders","colfooters","rowtitle","coltitle","push","gridLayoutGroups","boundFlush","boundFull","off","cells","headerBand","layoutHeaders","footerBand","titleAnchor","titleBand","layoutTitle","field","headers","limit","agg","isX","bf","start","stride","back","j","k","h","init","edge","warn","legendParams","config","xb","yb","w","legends","offsets","mult","column","row","legendLayout","legend","_bounds","ex","ey","tpad","tx","ty","legendTitleOffset","legendGroupLayout","legendBounds","entries","widths","legendEntryLayout","lr","noBar","grad","vgrad","u","o","ViewLayout","layout","viewBounds","xBounds","yBounds","l","equals","autosize","pos","frame","subtitle","end","sx","sy","text","titleLayout","_autosize","viewWidth","_width","viewHeight","_height","left","top","right","bottom","contains","_resizeView","resize","viewSizeLayout","layoutGroup"],"mappings":"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"}